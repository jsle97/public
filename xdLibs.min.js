/* xdLibs.js library - merged libs: xdTok.js, xdbLite.js, xdSrv.js, xdReq.js
 * Status: Private prototype
 * License: MIT
 * ------------------------------------------------------------------------------
 * Copyright (c) 2026 Jakub Śledzikowski <jsledzikowski.web@gmail.com>
 *
 */

import http from"http";import https from"https";import{URL,URLSearchParams}from"url";import{gunzipSync,inflateSync,brotliDecompressSync}from"zlib";import fs from"node:fs/promises";import fsSync from"node:fs";import path from"node:path";import crypto from"node:crypto";import{EventEmitter}from"node:events";let CHARSET="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_",RADIX=64,TIMESTAMP_LENGTH=9,INSTANCE_LENGTH=3,COUNTER_LENGTH=4,_DEFAULT_LENGTH=36,PREFIX_LENGTH=24,HASH_KEY="xddd666_lol",MIN_LENGTH=TIMESTAMP_LENGTH+INSTANCE_LENGTH+COUNTER_LENGTH,MAX_COUNTER=RADIX**COUNTER_LENGTH-1,DEFAULT_LENGTH=_DEFAULT_LENGTH<MIN_LENGTH?MIN_LENGTH:_DEFAULT_LENGTH,state={lastTimestamp:-1,counter:0,instanceId:(()=>{let t="";for(let e=0;e<INSTANCE_LENGTH;e++)t+=CHARSET[Math.floor(Math.random()*RADIX)];return t})()},toBase64=(e,t)=>{let r="",a=e;for(;0<a;)r=CHARSET[a%RADIX]+r,a=Math.floor(a/RADIX);return r.padStart(t,CHARSET[0])},generateRandomString=t=>{if(t<=0)return"";let r="";for(let e=0;e<t;e++)r+=CHARSET[Math.floor(Math.random()*RADIX)];return r},xdTok=(e=DEFAULT_LENGTH)=>{if((e="number"==typeof e?Math.floor(e):DEFAULT_LENGTH)<6||96<e)throw new Error("Token length must be between 6 and 96 characters.");var t=Date.now(),r=(t<state.lastTimestamp?console.warn(`Clock went back: ${t} < ${state.lastTimestamp}. Instance: ${state.instanceId}. Strict monotonicity broken.`):t>state.lastTimestamp&&(state.lastTimestamp=t,state.counter=0),state.counter>MAX_COUNTER&&(console.warn(`Counter overflow detected at timestamp ${state.lastTimestamp}. Instance: ${state.instanceId}. Resetting counter. Collision risk increases.`),state.counter=0),state.counter++),t=toBase64(t,TIMESTAMP_LENGTH),r=toBase64(r,COUNTER_LENGTH),t=t+state.instanceId+r,r=e-MIN_LENGTH;return 0<=r?t+generateRandomString(r):t.slice(0,e)},xdDrawNum=(e=0,t=999)=>{let i={a:Math.floor(e),b:Math.floor(t),s:0,l:0,h:0,set:(e=0,t=9)=>{if(i.a=Math.floor(e),i.b=Math.floor(t),i.b<i.a)throw new RangeError("M<$");return i},next:()=>{if(i.b<i.a)throw new RangeError("Invalid range");var t=i.a,r=i.b-t+1;if(r<=0)throw new RangeError("Invalid range");var a=Date.now(),e="undefined"!=typeof globalThis&&globalThis.performance&&"function"==typeof globalThis.performance.now?globalThis.performance.now():0,o=(i.s=(i.s+1)%r,i.s+Math.floor(a/1e3)+Math.floor(e));if("undefined"!=typeof globalThis&&globalThis.crypto&&"function"==typeof globalThis.crypto.getRandomValues){var n=new Uint32Array(1),s=Math.floor(4294967296/r)*r;let e;for(;globalThis.crypto.getRandomValues(n),(e=(n[0]^a^o)>>>0)>=s;);return t+e%r}e=Math.random()*r;return t+Math.floor((e+o)%r)}};return(e||t?i.set(e,t):i).next()},simpleHash=(e,t)=>{var r=new TextEncoder,e=r.encode(e),a=r.encode(t),o=new Uint8Array(e);for(let e=0;e<o.length;e++)o[e]^=a[e%a.length];for(let e=0;e<o.length;e++)o[e]^=a[a.length-1-e%a.length];for(let e=0;e<o.length-1;e+=2){var n=o[e];o[e]=o[e+1],o[e+1]=n}for(let e=0;e<o.length;e++)o[e]=255&(o[e]<<3|o[e]>>>5);return o},simpleUnhash=(e,t)=>{var r=new TextEncoder,a=new TextDecoder,o=r.encode(t),n=new Uint8Array(e);for(let e=0;e<n.length;e++)n[e]=255&(n[e]>>>3|n[e]<<5);for(let e=0;e<n.length-1;e+=2){var s=n[e];n[e]=n[e+1],n[e+1]=s}for(let e=0;e<n.length;e++)n[e]^=o[o.length-1-e%o.length];for(let e=0;e<n.length;e++)n[e]^=o[e%o.length];return a.decode(n)},xdHash=e=>{if("string"!=typeof e||0===e.length)return null;try{var t=xdTok(8),r=xdTok(PREFIX_LENGTH),a=HASH_KEY+t,o=simpleHash(e,a),n=String.fromCharCode(...o);return r+t+btoa(n)}catch(e){return null}},xdUnHash=e=>{if("string"!=typeof e||e.length<=PREFIX_LENGTH+8)return null;try{var t=e.slice(PREFIX_LENGTH,PREFIX_LENGTH+8),r=e.slice(PREFIX_LENGTH+8),a=atob(r),o=new Uint8Array(a.length);for(let e=0;e<a.length;e++)o[e]=a.charCodeAt(e);return simpleUnhash(o,HASH_KEY+t)}catch(e){return null}},XDB_ERROR_CODES={FILE_NOT_FOUND:"XDB_FILE_NOT_FOUND",DIR_NOT_FOUND:"XDB_DIR_NOT_FOUND",IO_ERROR:"XDB_IO_ERROR",INVALID_JSON:"XDB_INVALID_JSON",RECORD_NOT_FOUND:"XDB_RECORD_NOT_FOUND",RECORD_EXISTS:"XDB_RECORD_EXISTS",OPERATION_FAILED:"XDB_OPERATION_FAILED"},LOG_LEVELS={DEBUG:10,INFO:20,WARN:30,ERROR:40,NONE:100},__filename="",__dirname=process.cwd(),basePath=__dirname,DEFAULT_XDB_ID_LENGTH=16,DEFAULT_LOCK_TIMEOUT=5e3,fileLocks=new Map,lockCleanup=new Set,dataCache=new Map,currentLogLevel=LOG_LEVELS.INFO,cachingEnabled=!1,cacheTTL=6e4;function log(t,e,...r){if(!(t<currentLogLevel)){var a=`[${(new Date).toISOString()}] [${Object.keys(LOG_LEVELS).find(e=>LOG_LEVELS[e]===t)||"UNKNOWN"}] `+e;switch(t){case LOG_LEVELS.DEBUG:console.debug(a,...r);break;case LOG_LEVELS.INFO:console.log(a,...r);break;case LOG_LEVELS.WARN:console.warn(a,...r);break;case LOG_LEVELS.ERROR:console.error(a,...r)}}}function createXdbError(e,t=XDB_ERROR_CODES.OPERATION_FAILED){e=new Error(e);return e.code=t,e}function ensureJsonExtension(e){return e.toLowerCase().endsWith(".json")?e:e+".json"}async function ensureDirectoryExists(t){try{await fs.mkdir(t,{recursive:!0})}catch(e){if("EEXIST"!==e.code)throw createXdbError(`Błąd tworzenia katalogu ${t}: `+e.message,XDB_ERROR_CODES.IO_ERROR)}}function generateId(r=DEFAULT_XDB_ID_LENGTH){try{var a=crypto.randomBytes(Math.ceil(.75*r)).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"");return(Date.now().toString(36)+a).slice(0,r)}catch(e){log(LOG_LEVELS.WARN,"Nie udało się użyć crypto, używam zapasowego generatora ID: "+e.message);let t="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_";a=Date.now().toString(36);return(a+Array(r-a.length).fill(0).map(()=>t.charAt(Math.floor(Math.random()*t.length))).join("")).slice(0,r)}}function getCacheKey(e,t=null){return e=ensureJsonExtension(e),t?e+":"+t:e}function getCachedData(e,t=null){return cachingEnabled&&(e=getCacheKey(e,t),t=dataCache.get(e))?Date.now()-t.timestamp>cacheTTL?(dataCache.delete(e),null):(log(LOG_LEVELS.DEBUG,"Cache hit dla: "+e),t.data):null}function setCachedData(e,t,r=null){cachingEnabled&&(e=getCacheKey(e,r),dataCache.set(e,{data:t,timestamp:Date.now()}),log(LOG_LEVELS.DEBUG,"Dodano do cache: "+e))}function invalidateCache(e,t=null){if(cachingEnabled)if(t){t=getCacheKey(e,t);dataCache.delete(t),log(LOG_LEVELS.DEBUG,"Usunięto z cache: "+t)}else{var r,a=getCacheKey(e);for(r of dataCache.keys())r!==a&&!r.startsWith(a+":")||(dataCache.delete(r),log(LOG_LEVELS.DEBUG,"Usunięto z cache: "+r))}}function clearAllCache(){dataCache.clear(),log(LOG_LEVELS.INFO,"Wyczyszczono cały cache")}let LOCK_TIMEOUT=3e4,LOCK_RETRY_INTERVAL=50,LOCK_MAX_RETRIES=600;function cleanupLocks(){log(LOG_LEVELS.INFO,"Cleaning up file locks due to process termination");for(var[e,t]of fileLocks.entries()){if(t.release)try{t.release()}catch(e){}fileLocks.delete(e)}lockCleanup.clear()}async function acquireLock(t,r=LOCK_TIMEOUT){let a=path.resolve(getBasePath(),t);var o=Date.now();let e=process.pid;if(log(LOG_LEVELS.DEBUG,`Próba uzyskania blokady dla: ${t} (PID: ${e})`),lockCleanup.has(a+":"+e))throw createXdbError(`Process ${e} already holds lock for ${t} - potential deadlock`,XDB_ERROR_CODES.OPERATION_FAILED);let n=0;for(;fileLocks.has(a);){if(Date.now()-o>r)throw createXdbError(`Timeout podczas oczekiwania na blokadę pliku ${t} po ${r}ms`,XDB_ERROR_CODES.OPERATION_FAILED);let e=fileLocks.get(a);if(e&&e.expiresAt<Date.now()){if(log(LOG_LEVELS.WARN,"Usuwam wygasłą blokadę dla: "+a),e.release)try{e.release()}catch(e){}fileLocks.delete(a),lockCleanup.delete(a+":"+e.processId);break}if(++n>LOCK_MAX_RETRIES)throw createXdbError("Przekroczono maksymalną liczbę prób uzyskania blokady dla: "+t,XDB_ERROR_CODES.OPERATION_FAILED);await new Promise(e=>setTimeout(e,LOCK_RETRY_INTERVAL))}let s,i={promise:new Promise(e=>{s=e}),release:()=>s(),expiresAt:Date.now()+r,processId:e,filePath:a};return fileLocks.set(a,i),lockCleanup.add(a+":"+e),log(LOG_LEVELS.DEBUG,`Uzyskano blokadę dla: ${t} (PID: ${e})`),()=>releaseLock(a,s,e)}function releaseLock(e,t,r){var a;fileLocks.has(e)&&((a=fileLocks.get(e)).processId===r?(t&&"function"==typeof t&&t(),fileLocks.delete(e),lockCleanup.delete(e+":"+r),log(LOG_LEVELS.DEBUG,`Zwolniono blokadę dla: ${e} (PID: ${r})`)):log(LOG_LEVELS.WARN,`Próba zwolnienia blokady przez niewłaściwy proces: ${r} != `+a.processId))}process.once("SIGINT",cleanupLocks),process.once("SIGTERM",cleanupLocks);let createCentralErrorHandler=()=>{let o=new Set,n=new Map,a=(process.on("unhandledRejection",(e,t)=>{var r,a=Date.now()+Math.random().toString(36).substr(2,9);n.set(t,{reason:e,timestamp:Date.now(),errorId:a}),log(LOG_LEVELS.ERROR,`Unhandled Promise Rejection (ID: ${a}):`,e);for(r of o)try{r("unhandledRejection",{reason:e,promise:t,errorId:a})}catch(e){}}),process.on("rejectionHandled",e=>{n.delete(e)}),(e,t={})=>{var r,a={...t,message:e?.message||String(e),stack:e?.stack,code:e?.code,timestamp:Date.now()};log(LOG_LEVELS.ERROR,"Central Error Handler:",a);for(r of o)try{r("error",a)}catch(e){}return a});return{handleError:a,handleAsyncError:async(e,t={})=>{try{return await e()}catch(e){return a(e,t)}},wrapAsyncOperation:(e,r={})=>async(...t)=>{try{return await e(...t)}catch(e){throw a(e,{...r,args:0<t.length?t:void 0})}},addListener:e=>o.add(e),removeListener:e=>o.delete(e),getUnhandledRejections:()=>[...n.values()]}},errorHandler=createCentralErrorHandler();async function safeParseJSON(r){let a=path.resolve(basePath,r);var e=getCachedData(r);return null!==e?e:errorHandler.handleAsyncError(async()=>{var e=await fs.readFile(a,"utf-8");try{var t=JSON.parse(e);return setCachedData(r,t),t}catch(e){throw createXdbError(`Nieprawidłowy JSON w pliku ${r}: `+e.message,XDB_ERROR_CODES.INVALID_JSON)}},{operation:"safeParseJSON",filePath:r})}function validateId(e){if("string"!=typeof e||0===e.length)throw createXdbError("Nieprawidłowe ID: ID musi być niepustym stringiem. Otrzymano: "+e,XDB_ERROR_CODES.OPERATION_FAILED)}function validateRecord(e){if(!e||"object"!=typeof e||Array.isArray(e))throw createXdbError("Rekord musi być niepustym obiektem.",XDB_ERROR_CODES.OPERATION_FAILED)}async function cleanupTempFile(t){if(t)try{await fs.unlink(t)}catch(e){"ENOENT"!==e.code&&log(LOG_LEVELS.WARN,`Nie udało się usunąć pliku tymczasowego ${t}: `+e.message)}}function getBasePath(){return basePath}async function atomicWrite(t,e){var r=path.resolve(getBasePath(),t);let a,o;try{a=r+".tmp"+Date.now()+Math.random(),await ensureDirectoryExists(path.dirname(r)),await(o=await fs.open(a,"w")).writeFile(e,"utf-8"),await o.sync(),await o.close(),o=null,await fs.rename(a,r),log(LOG_LEVELS.DEBUG,"Pomyślnie zapisano plik: "+t),invalidateCache(t)}catch(e){if(o)try{await o.close()}catch(e){log(LOG_LEVELS.WARN,"Nie udało się zamknąć uchwytu pliku tymczasowego: "+e.message)}throw await cleanupTempFile(a),createXdbError(`Atomowy zapis do ${t} nie powiódł się: `+e.message,XDB_ERROR_CODES.IO_ERROR)}}async function setConfig(e={}){if(e.basePath&&(basePath=path.resolve(e.basePath),log(LOG_LEVELS.INFO,"Ustawiono ścieżkę bazową: "+basePath)),void 0!==e.logLevel){let t=e.logLevel.toUpperCase?e.logLevel.toUpperCase():e.logLevel;var r;"string"==typeof t&&void 0!==LOG_LEVELS[t]?(currentLogLevel=LOG_LEVELS[t],log(LOG_LEVELS.INFO,"Ustawiono poziom logowania: "+t)):"number"==typeof t&&(currentLogLevel=t,r=Object.keys(LOG_LEVELS).find(e=>LOG_LEVELS[e]===t),log(LOG_LEVELS.INFO,"Ustawiono poziom logowania: "+(r||t)))}return void 0!==e.cachingEnabled&&(cachingEnabled=!!e.cachingEnabled,log(LOG_LEVELS.INFO,"Cache "+(cachingEnabled?"włączony":"wyłączony")),cachingEnabled||clearAllCache()),void 0!==e.cacheTTL&&"number"==typeof e.cacheTTL&&0<e.cacheTTL&&(cacheTTL=e.cacheTTL,log(LOG_LEVELS.INFO,`Ustawiono TTL cache: ${cacheTTL}ms`)),{basePath:getBasePath(),logLevel:currentLogLevel,cachingEnabled:cachingEnabled,cacheTTL:cacheTTL}}async function addDir(t){try{var e=path.resolve(getBasePath(),t);return await ensureDirectoryExists(e),log(LOG_LEVELS.INFO,"Utworzono katalog: "+t),{path:e}}catch(e){throw log(LOG_LEVELS.ERROR,`Błąd podczas tworzenia katalogu ${t}: `+e.message),createXdbError(`Nie udało się utworzyć katalogu ${t}: `+e.message,XDB_ERROR_CODES.IO_ERROR)}}async function delDir(t){let e=null;var r=path.resolve(getBasePath(),t);try{e=await acquireLock(t);try{await fs.stat(r)}catch(e){if("ENOENT"===e.code)throw createXdbError(`Katalog ${t} nie istnieje.`,XDB_ERROR_CODES.DIR_NOT_FOUND);throw e}return await fs.rm(r,{recursive:!0,force:!0}),log(LOG_LEVELS.INFO,"Usunięto katalog: "+t),{path:r}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas usuwania katalogu ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się usunąć katalogu ${t}: `+e.message,XDB_ERROR_CODES.IO_ERROR)}finally{e&&e()}}async function renameDir(t,r){let e=null;var a=path.resolve(getBasePath(),t),o=path.resolve(getBasePath(),r);try{e=await acquireLock(t);try{await fs.stat(a)}catch(e){if("ENOENT"===e.code)throw createXdbError(`Katalog źródłowy ${t} nie istnieje.`,XDB_ERROR_CODES.DIR_NOT_FOUND);throw createXdbError(`Nie udało się uzyskać dostępu do katalogu źródłowego ${t}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}return await ensureDirectoryExists(path.dirname(o)),await fs.rename(a,o),log(LOG_LEVELS.INFO,`Zmieniono nazwę katalogu z ${t} na `+r),{oldPath:a,newPath:o}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas zmiany nazwy katalogu z ${t} na ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się zmienić nazwy katalogu z ${t} na ${r}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{e&&e()}}async function moveFile(t,r){let e=null;t=ensureJsonExtension(t),r=ensureJsonExtension(r);var a=path.resolve(getBasePath(),t),o=path.resolve(getBasePath(),r);try{e=await acquireLock(t);try{await fs.stat(a)}catch(e){if("ENOENT"===e.code)throw createXdbError(`Plik źródłowy ${t} nie istnieje.`,XDB_ERROR_CODES.FILE_NOT_FOUND);throw createXdbError(`Nie udało się uzyskać dostępu do pliku źródłowego ${t}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}return await ensureDirectoryExists(path.dirname(o)),await fs.rename(a,o),invalidateCache(t),log(LOG_LEVELS.INFO,`Przeniesiono plik z ${t} do `+r),{source:a,target:o}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas przenoszenia pliku z ${t} do ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się przenieść pliku z ${t} do ${r}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{e&&e()}}async function addAll(r,a=[],o={overwrite:!0}){let n=null;r=ensureJsonExtension(r);var s=path.resolve(basePath,r);try{if(!a||"object"!=typeof a)throw createXdbError("Nieprawidłowe dane: Dane muszą być tablicą lub obiektem.",XDB_ERROR_CODES.OPERATION_FAILED);let t=a;if(Array.isArray(a)){var i=(t=a.map(e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw createXdbError("Rekord musi być niepustym obiektem.",XDB_ERROR_CODES.OPERATION_FAILED);let t=e.id;return t=null==t?generateId():String(t),{...e,id:t}})).map(e=>e.id);if(new Set(i).size!==i.length)throw createXdbError("Znaleziono zduplikowane ID w dostarczonych danych.",XDB_ERROR_CODES.RECORD_EXISTS)}else{validateRecord(a);let e=a.id;e=null==e?generateId():String(e),t={...a,id:e}}n=await acquireLock(r),await ensureDirectoryExists(path.dirname(s));let e=!1;try{await fs.stat(s),e=!0}catch(e){if("ENOENT"!==e.code)throw e}if(e&&!o.overwrite)throw createXdbError(`Plik ${r} już istnieje. Ustaw options.overwrite na true, aby nadpisać.`,XDB_ERROR_CODES.OPERATION_FAILED);var l=Array.isArray(t)?t:[t];return await atomicWrite(r,JSON.stringify(l)),log(LOG_LEVELS.INFO,`Dodano ${l.length} rekordów do `+r),{path:s}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas dodawania danych do ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się dodać danych do ${r}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{n&&n()}}async function addRecordById(r,e){let a=null;r=ensureJsonExtension(r);var o=path.resolve(basePath,r);try{validateRecord(e),a=await acquireLock(r);var n=await safeParseJSON(r);if(!Array.isArray(n))throw createXdbError(`Nie można dodać rekordu: Plik ${r} istnieje, ale nie zawiera tablicy JSON.`,XDB_ERROR_CODES.OPERATION_FAILED);let t={...e};if(null==t.id){t.id=generateId();let e=0;for(;n.some(e=>String(e.id)===String(t.id))&&e<10;)t.id=generateId(),e++,log(LOG_LEVELS.DEBUG,`Kolizja ID, próba ${e}/10: `+t.id);if(10<=e)throw createXdbError(`Nie udało się wygenerować unikalnego ID dla ${r} po 10 próbach.`,XDB_ERROR_CODES.OPERATION_FAILED)}else if(t.id=String(t.id),validateId(t.id),n.some(e=>String(e.id)===String(t.id)))throw createXdbError(`Rekord z ID ${t.id} już istnieje w ${r}.`,XDB_ERROR_CODES.RECORD_EXISTS);return n.push(t),await atomicWrite(r,JSON.stringify(n)),log(LOG_LEVELS.INFO,`Dodano rekord z ID ${t.id} do `+r),{path:o,record:t}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas dodawania rekordu do ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się dodać rekordu do ${r}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{a&&a()}}async function editAll(t,e){let r=null;t=ensureJsonExtension(t);var a=path.resolve(basePath,t);try{if(!e||"object"!=typeof e)throw createXdbError("Nieprawidłowe dane: Dane muszą być tablicą lub obiektem.",XDB_ERROR_CODES.OPERATION_FAILED);if(Array.isArray(e))for(var o of e)try{validateRecord(o),null!=o.id&&(o.id=String(o.id),validateId(o.id))}catch(e){throw createXdbError("Nieprawidłowy rekord w tablicy danych: "+e.message,XDB_ERROR_CODES.OPERATION_FAILED)}r=await acquireLock(t);var n=Array.isArray(e)?e:[e];return await atomicWrite(t,JSON.stringify(n)),log(LOG_LEVELS.INFO,`Zaktualizowano ${t} - ${n.length} rekordów`),{path:a}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas edycji danych w ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się edytować danych w ${t}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{r&&r()}}async function editRecordById(r,a,e){let o=null;r=ensureJsonExtension(r);var n=path.resolve(basePath,r);try{let t=String(a);validateId(t),validateRecord(e),o=await acquireLock(r);var s=await safeParseJSON(r);if(!Array.isArray(s))throw createXdbError(`Nie można edytować rekordu po ID: Plik ${r} nie zawiera tablicy JSON.`,XDB_ERROR_CODES.OPERATION_FAILED);var i=s.findIndex(e=>String(e.id)===t);if(-1===i)throw createXdbError(`Rekord z ID ${t} nie został znaleziony w ${r}.`,XDB_ERROR_CODES.RECORD_NOT_FOUND);var l={...s[i]},c={...l,...e,id:l.id};return s[i]=c,await atomicWrite(r,JSON.stringify(s)),log(LOG_LEVELS.INFO,`Zaktualizowano rekord z ID ${t} w `+r),setCachedData(r,c,t),{path:n,record:c}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas edycji rekordu z ID ${a} w ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się edytować rekordu z ID ${a} w ${r}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{o&&o()}}async function deleteAll(t){let e=null;t=ensureJsonExtension(t);var r=path.resolve(basePath,t);try{e=await acquireLock(t);try{await fs.stat(r),await atomicWrite(t,JSON.stringify([]))}catch(e){if("ENOENT"===e.code)return{path:r};throw e}return log(LOG_LEVELS.INFO,"Usunięto wszystkie rekordy z "+t),{path:r}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas usuwania wszystkich rekordów z ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się usunąć wszystkich rekordów z ${t}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{e&&e()}}async function deleteRecordById(r,a){let e=null;r=ensureJsonExtension(r);var o=path.resolve(basePath,r);try{let t=String(a);validateId(t),e=await acquireLock(r);var n=await safeParseJSON(r);if(!Array.isArray(n))throw createXdbError(`Nie można usunąć rekordu po ID: Plik ${r} nie zawiera tablicy JSON.`,XDB_ERROR_CODES.OPERATION_FAILED);var s=n.length,i=n.filter(e=>String(e.id)!==t);if(s===i.length)throw createXdbError(`Rekord z ID ${t} nie został znaleziony w ${r}.`,XDB_ERROR_CODES.RECORD_NOT_FOUND);return await atomicWrite(r,JSON.stringify(i)),log(LOG_LEVELS.INFO,`Usunięto rekord z ID ${t} z `+r),invalidateCache(r,t),{path:o,deletedId:t}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas usuwania rekordu z ID ${a} z ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się usunąć rekordu z ID ${a} z ${r}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{e&&e()}}async function viewAll(t){try{var e=await safeParseJSON(t=ensureJsonExtension(t));return{path:path.resolve(basePath,t),data:e}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas pobierania danych z ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się pobrać danych z ${t}: `+e.message,e.code||XDB_ERROR_CODES.OPERATION_FAILED)}}async function viewRecordById(r,a){try{let t=String(a);validateId(t);var e=getCachedData(r,t);if(null!==e)return{path:path.resolve(basePath,r),record:e,fromCache:!0};r=ensureJsonExtension(r);var o=path.resolve(basePath,r),n=await safeParseJSON(r);if(!Array.isArray(n))throw createXdbError(`Nie można pobrać rekordu po ID: Plik ${r} nie zawiera tablicy JSON.`,XDB_ERROR_CODES.OPERATION_FAILED);var s=n.find(e=>String(e.id)===t);if(s)return setCachedData(r,s,t),{path:o,record:s};throw createXdbError(`Rekord z ID ${t} nie został znaleziony w ${r}.`,XDB_ERROR_CODES.RECORD_NOT_FOUND)}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas pobierania rekordu z ID ${a} z ${r}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się pobrać rekordu z ID ${a} z ${r}: `+e.message,e.code||XDB_ERROR_CODES.OPERATION_FAILED)}}async function viewMore(t,r={}){try{let e=await safeParseJSON(t=ensureJsonExtension(t));if(!Array.isArray(e))throw createXdbError(`Nie można wykonać zapytania: Plik ${t} nie zawiera tablicy JSON.`,XDB_ERROR_CODES.OPERATION_FAILED);if(r.filter&&"function"==typeof r.filter)try{e=e.filter(r.filter)}catch(e){throw createXdbError("Błąd podczas filtrowania: "+e.message,XDB_ERROR_CODES.OPERATION_FAILED)}if(r.sort){let n=Array.isArray(r.sort)?r.sort:[r.sort];try{e.sort((e,t)=>{for(var r of n){var{key:r,order:a="asc"}=r,a="desc"===a.toLowerCase()?-1:1;if(r&&"string"==typeof r){var o=e[r],r=t[r];if(o!==r){if(null==o)return a;if(null==r)return-1*a;if(o<r)return-1*a;if(r<o)return a}}}return 0})}catch(e){throw createXdbError("Błąd podczas sortowania: "+e.message,XDB_ERROR_CODES.OPERATION_FAILED)}}var a=r.skip&&Number.isInteger(r.skip)&&0<r.skip?r.skip:0,o=r.limit&&Number.isInteger(r.limit)&&0<r.limit?r.limit:e.length,n=e.slice(a,a+o),s=e.length;return log(LOG_LEVELS.DEBUG,`Pobrano ${n.length} z ${s} rekordów z `+t),{path:path.resolve(basePath,t),data:n,meta:{total:s,skip:a,limit:o,page:Math.floor(a/o)+1,totalPages:Math.ceil(s/o)}}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas zapytania do ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się wykonać zapytania do ${t}: `+e.message,e.code||XDB_ERROR_CODES.OPERATION_FAILED)}}async function del(t){let e=null;t=ensureJsonExtension(t);var r=path.resolve(basePath,t);try{e=await acquireLock(t);try{await fs.unlink(r),log(LOG_LEVELS.INFO,"Usunięto plik: "+t)}catch(e){if("ENOENT"!==e.code)throw e;log(LOG_LEVELS.INFO,`Plik ${t} nie istniał, operacja zakończona sukcesem`)}return invalidateCache(t),{path:r}}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas usuwania pliku ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się usunąć pliku ${t}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}finally{e&&e()}}async function listDir(t){try{var e=path.resolve(getBasePath(),t);try{await fs.stat(e)}catch(e){if("ENOENT"===e.code)throw createXdbError(`Katalog ${t} nie istnieje.`,XDB_ERROR_CODES.DIR_NOT_FOUND);throw e}var r=await fs.readdir(e);return log(LOG_LEVELS.INFO,`Wylistowano ${r.length} elementów z katalogu: `+t),r}catch(e){if(log(LOG_LEVELS.ERROR,`Błąd podczas listowania katalogu ${t}: `+e.message),e.code&&Object.values(XDB_ERROR_CODES).includes(e.code))throw e;throw createXdbError(`Nie udało się wylistować katalogu ${t}: `+e.message,e.code||XDB_ERROR_CODES.IO_ERROR)}}let xdBLite={config:setConfig,dir:{add:addDir,del:delDir,rename:renameDir,list:listDir},move:{file:moveFile},edit:{all:editAll,id:editRecordById},del:{file:del,all:deleteAll,id:deleteRecordById},add:{all:addAll,id:addRecordById},view:{all:viewAll,id:viewRecordById,more:viewMore},cache:{clear:clearAllCache,invalidate:invalidateCache}},xdbLite=xdBLite,WS_GUID="258EAFA5-E914-47DA-95CA-C5AB0DC85B11",WS_READY_STATES=Object.freeze({CONNECTING:0,OPEN:1,CLOSING:2,CLOSED:3}),WS_OPCODES=Object.freeze({CONTINUATION:0,TEXT:1,BINARY:2,CLOSE:8,PING:9,PONG:10}),HOP_BY_HOP_HEADERS=new Set(["connection","keep-alive","proxy-authenticate","proxy-authorization","te","trailer","transfer-encoding","upgrade"]),DEFAULT_MIME_TYPES=Object.freeze({html:"text/html; charset=utf-8",css:"text/css; charset=utf-8",js:"application/javascript; charset=utf-8",mjs:"application/javascript; charset=utf-8",json:"application/json; charset=utf-8",txt:"text/plain; charset=utf-8",svg:"image/svg+xml",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",webp:"image/webp",ico:"image/x-icon",woff:"font/woff",woff2:"font/woff2",wasm:"application/wasm",map:"application/json; charset=utf-8",avif:"image/avif",bmp:"image/bmp"}),HTML_RE=/[&<>"']/g,HTML_UNQUOTED_RE=/[&<>"'`=\/ \t\n\r]/g,HTML_ESCAPES=Object.freeze({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),HTML_UNQUOTED_ESCAPES=Object.freeze({...HTML_ESCAPES,"`":"&#96;","=":"&#61;","/":"&#47;"," ":"&#32;","\t":"&#9;","\n":"&#10;","\r":"&#13;"}),JS_ESC_RE=/[\\'"`\u2028\u2029<&/]/g,CSS_SAFE_RE=/[^a-zA-Z0-9 _\-.,]/g,URL_PROTOCOL_RE=/^\s*([a-zA-Z][a-zA-Z0-9+.-]*):/,END_SCRIPT_RE=/<\/script/gi,DEFAULT_ESCAPE_OPTIONS=Object.freeze({handleObjects:"convert",context:"auto",quote:'"',targetName:null,inAttribute:!1,urlPolicy:Object.freeze({allow:["http","https","mailto","tel","data"],dataMimeAllow:/^image\/(png|gif|jpeg|webp|svg\+xml)$/i,onFail:"about:blank"}),normalize:!1}),safeJsonStringify=e=>{let r=new WeakSet;return JSON.stringify(e,(e,t)=>{if("object"==typeof t&&null!==t){if(r.has(t))return"[Circular]";r.add(t)}return t})||""},parseUrlSearchParams=e=>Object.fromEntries(new URLSearchParams(e)),createErrorWithCode=(e,t)=>{e=new Error(e);return e.code=t,e},createRegexPattern=e=>e.includes(":")?new RegExp("^"+e.replace(/:(\w+)/g,"(?<$1>[^/]+)")+"$"):null,mapReplace=(e,t,r)=>e.replace(t,e=>r[e]||e),toStringSafe=(e,t={})=>{if(null==e)return"";if("string"==typeof e)return t.normalize?e.normalize("NFC"):e;if("number"!=typeof e&&"bigint"!=typeof e&&"boolean"!=typeof e&&"symbol"!=typeof e){if(e instanceof Date)return isNaN(e.getTime())?"":e.toISOString();t=t.handleObjects||"convert";if("empty"===t)return"";if("json"===t)return safeJsonStringify(e);if("throw"===t)throw new TypeError("Non-primitive values not allowed")}return String(e)},cssEscapeIdent=t=>{let r="";for(let e=0;e<t.length;e++){var a=t[e],o=t.charCodeAt(e);48<=o&&o<=57||65<=o&&o<=90||97<=o&&o<=122||"-"===a||"_"===a?0===e&&48<=o&&o<=57?r+="\\3"+a+" ":r+=a:r+="\\"+o.toString(16)+" "}return r},cssEscapeString=e=>e.replace(CSS_SAFE_RE,e=>"\\"+e.codePointAt(0).toString(16)+" "),jsEscapeString=(e,t)=>e.replace(JS_ESC_RE,e=>{switch(e){case"\\":return"\\\\";case t:return"\\"+t;case"`":return"\\`";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";case"<":return"\\x3C";case"&":return"\\x26";case"/":return"\\/";default:return e}}),isSafeUrl=(e,t)=>{var r,a=String(e).match(URL_PROTOCOL_RE);return a?"data"===(r=a[1].toLowerCase())?t.allow.includes("data")&&(a=(a=String(e).slice(a[0].length).match(/^([^;,]+)[;,]/))?a[1].trim():"",t.dataMimeAllow.test(a))?{ok:!0,url:e}:{ok:!1}:t.allow.includes(r)?{ok:!0,url:e}:{ok:!1}:{ok:!0,url:e}},sanitizeUrl=(e,t)=>{if(isSafeUrl(e,t).ok)return String(e);switch(t.onFail){case"strip":return"";case"throw":throw new Error("Blocked URL protocol");default:return"about:blank"}},detectContext=(e,t)=>{var r;return t.inAttribute&&t.targetName?(r=t.targetName.toLowerCase(),/^on/.test(r)?"jsString":"style"===r?"cssString":/^(href|src|xlink:href|action|formaction|poster|data)$/i.test(r)?"url":t.quote?"htmlAttribute":"htmlAttributeUnquoted"):"htmlContent"},isValidUTF8=e=>{try{var t=e.toString("utf8");return Buffer.from(t,"utf8"),!0}catch{return!1}},escapeAny=(e,t={})=>{var r={...DEFAULT_ESCAPE_OPTIONS,...t};let a=toStringSafe(e,r);switch(r.normalize&&"function"==typeof a.normalize&&(a=a.normalize("NFC")),"auto"===r.context?detectContext(a,r):r.context){case"htmlContent":case"htmlAttribute":return mapReplace(a,HTML_RE,HTML_ESCAPES);case"htmlAttributeUnquoted":return mapReplace(a,HTML_UNQUOTED_RE,HTML_UNQUOTED_ESCAPES);case"htmlComment":return a.replace(/--/g,"&#45;&#45;").replace(/>/g,">").replace(/</g,"<");case"jsString":return jsEscapeString(a,"'"===r.quote?"'":"`"===r.quote?"`":'"');case"scriptData":return a.replace(END_SCRIPT_RE,"<\\/script").replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029");case"cssString":return cssEscapeString(a);case"cssIdent":return cssEscapeIdent(a);case"cssUrl":return`url("${mapReplace(sanitizeUrl(a,r.urlPolicy),HTML_RE,HTML_ESCAPES)}")`;case"url":return sanitizeUrl(a,r.urlPolicy);case"urlComponent":return encodeURIComponent(a);default:return mapReplace(a,HTML_RE,HTML_ESCAPES)}},safeText=e=>escapeAny(e,{context:"htmlContent"}),safeAttr=(e,t,{quoted:r=!0,...a}={})=>{t=escapeAny(t,{context:"auto",inAttribute:!0,targetName:e,quote:r?'"':"",...a});return r?e+`="${t}"`:e+"="+t},safeUrlAttr=(e,t,r={})=>{t=escapeAny(t,{context:"url",inAttribute:!0,targetName:e,...r});return`${e}="${mapReplace(t,HTML_RE,HTML_ESCAPES)}"`},createCache=({max:l=500,ttl:c=0,maxMemoryBytes:d=1/0,updateAgeOnGet:r=!0,dispose:u=null}={})=>{let E=new Map,f=new Map,p=0,h=e=>{if("string"==typeof e)return Buffer.byteLength(e,"utf8");if(Buffer.isBuffer(e))return e.length;if("object"==typeof e)try{return Buffer.byteLength(JSON.stringify(e),"utf8")}catch{return 1024}return String(e).length},a=e=>{e=f.get(e);return void 0!==e&&e!==1/0&&Date.now()>e},o=e=>{var t,r;return!!E.has(e)&&(t=E.get(e),r=h(t),E.delete(e),f.delete(e),p-=r,u&&u(e,t,"delete"),!0)};let e=()=>{if(u)for(var[e,t]of E)u(e,t,"clear");E.clear(),f.clear(),p=0};let t=()=>{let e=0;for(var[t,r]of f)r!==1/0&&Date.now()>r&&(o(t),e++);return e},n=setInterval(()=>{var e=t();0<e&&log(LOG_LEVELS.DEBUG,`Auto-pruned ${e} expired items from cache`)},3e5);return process.once("beforeExit",()=>{clearInterval(n),e()}),{get:e=>{if(E.has(e)){var t;if(!a(e))return t=E.get(e),r&&(E.delete(e),E.set(e,t)),t;o(e)}},set:(e,t,r={})=>{var a,o,n,s,r=void 0!==r.ttl?r.ttl:c,r=r===1/0||r<=0?1/0:Date.now()+r,i=h(t);if(d<i)return log(LOG_LEVELS.WARN,`Item ${e} too large for cache: ${i} bytes > ${d} max`),!1;for(E.has(e)&&(a=E.get(e),a=h(a),p-=a,E.delete(e),f.delete(e));(E.size>=l||p+i>d)&&0<E.size&&(s=n=o=void 0)!==(s=E.keys().next().value)&&(o=E.get(s),n=h(o),E.delete(s),f.delete(s),p-=n,u&&u(s,o,"evict"),1););return p+i>d?(log(LOG_LEVELS.WARN,`Insufficient cache memory for ${e}: ${p+i} > `+d),!1):(E.set(e,t),f.set(e,r),p+=i,!0)},has:e=>!(!E.has(e)||a(e)&&(o(e),1)),delete:o,clear:e,keys:()=>{var e,t=[];for(e of E.keys())a(e)||t.push(e);return t[Symbol.iterator]()},size:()=>E.size,memoryUsage:()=>p,prune:t}},xdLRU=(e={})=>{var{max:e=500,ttl:t=0,updateAgeOnGet:r=!0,dispose:a=null}=e;return createCache({max:e,ttl:t,updateAgeOnGet:r,dispose:a})},createRedisInstance=({max:e=1e3}={})=>{let i=(e,t)=>({__type:e,data:t}),a=new Map,s=xdLRU({max:e,ttl:1/0,updateAgeOnGet:!0,dispose:e=>a.delete(e)}),t=e=>{e=a.get(e);return void 0!==e&&e!==1/0&&Date.now()>e},l=(e,t)=>{if(!e||e.__type!==t)throw new Error("WRONGTYPE Operation against a key holding the wrong kind of value")},c=(e,t,r=-1)=>{r=0<=r?Date.now()+1e3*r:1/0;a.set(e,r),s.set(e,t,{ttl:r===1/0?1/0:r-Date.now()})},d=e=>!t(e)||(s.delete(e),!1),u=e=>s.get(e),r=e=>d(e)&&s.has(e)?(e=a.get(e))===1/0?-1:Math.max(1,Math.ceil((e-Date.now())/1e3)):-2,E=e=>{e=r(e);return-2===e?-1:e},o={set:(e,t,{ttl:r=-1}={})=>(c(e,i("string",t),r),"OK"),get:e=>d(e)&&(e=u(e))?e.data:null,incr:e=>{var t=o.get(e),r=parseInt(t??0,10);if(Number.isNaN(r)&&null!==t)throw new Error("ERR value is not an integer or out of range");t=(Number.isNaN(r)?0:r)+1;return o.set(e,String(t),{ttl:E(e)}),t},decr:e=>{var t=o.get(e),r=parseInt(t??0,10);if(Number.isNaN(r)&&null!==t)throw new Error("ERR value is not an integer or out of range");t=(Number.isNaN(r)?0:r)-1;return o.set(e,String(t),{ttl:E(e)}),t},append:(e,t)=>{t=String(o.get(e)??"")+t;return o.set(e,t,{ttl:E(e)}),t.length}};var e={lpush:(e,...t)=>{d(e);var r,a=u(e),o=a?(l(a,"list"),a.data):[];for(r of t)o.unshift(String(r));return c(e,i("list",o),E(e)),o.length},rpush:(e,...t)=>{d(e);var r,a=u(e),o=a?(l(a,"list"),a.data):[];for(r of t)o.push(String(r));return c(e,i("list",o),E(e)),o.length},lpop:e=>{var t,r;return!d(e)||!s.has(e)||!(t=u(e))||(l(t,"list"),0===t.data.length)?null:(r=t.data.shift(),t.data.length?c(e,i("list",t.data),E(e)):h.del(e),r)},rpop:e=>{var t,r;return!d(e)||!s.has(e)||!(t=u(e))||(l(t,"list"),0===t.data.length)?null:(r=t.data.pop(),t.data.length?c(e,i("list",t.data),E(e)):h.del(e),r)},lrange:(e,t,r)=>{if(!d(e)||!s.has(e))return[];e=u(e);if(!e)return[];l(e,"list");let a=e.data.length;var o=e=>e<0?a+e:e,t=Math.max(0,o(t)),o=Math.min(a-1,o(r));return t<=o?e.data.slice(t,o+1):[]}},n={hset:(e,t,r)=>{d(e);var a=u(e),a=a?(l(a,"hash"),a.data):{},o=!(String(t)in a);return a[String(t)]=String(r),c(e,i("hash",a),E(e)),o?1:0},hget:(e,t)=>d(e)&&s.has(e)&&(e=u(e))?(l(e,"hash"),e.data[String(t)]??null):null,hdel:(e,...t)=>{if(!d(e)||!s.has(e))return 0;var r,a=u(e);if(!a)return 0;l(a,"hash");let o=0;for(r of t){var n=String(r);Object.prototype.hasOwnProperty.call(a.data,n)&&(delete a.data[n],o++)}return 0<o&&(Object.keys(a.data).length?c(e,i("hash",a.data),E(e)):h.del(e)),o},hkeys:e=>d(e)&&s.has(e)&&(e=u(e))?(l(e,"hash"),Object.keys(e.data)):[],hgetall:e=>d(e)&&s.has(e)&&(e=u(e))?(l(e,"hash"),{...e.data}):{}},f={sadd:(e,...t)=>{d(e);var r,a=u(e),o=a?(l(a,"set"),a.data):new Set;let n=0;for(r of t){var s=String(r);o.has(s)||(o.add(s),n++)}return(0<n||!a)&&c(e,i("set",o),E(e)),n},srem:(e,...t)=>{if(!d(e)||!s.has(e))return 0;var r,a=u(e);if(!a)return 0;l(a,"set");let o=0;for(r of t)a.data.delete(String(r))&&o++;return 0<o&&(a.data.size?c(e,i("set",a.data),E(e)):h.del(e)),o},smembers:e=>d(e)&&s.has(e)&&(e=u(e))?(l(e,"set"),[...e.data]):[],sismember:(e,t)=>d(e)&&s.has(e)&&(e=u(e))&&(l(e,"set"),e.data.has(String(t)))?1:0};let h={exists:e=>d(e)&&s.has(e),del:e=>s.delete(e),keys:(e="*")=>{var t,r=new RegExp("^"+e.replace(/\*/g,".*")+"$"),a=[];for(t of s.keys())d(t)&&s.has(t)&&r.test(t)&&a.push(t);return a},ttl:e=>r(e),expire:(e,t)=>{var r;return h.exists(e)?(t=1e3*t,a.set(e,Date.now()+t),void 0!==(r=s.get(e))&&s.set(e,r,{ttl:t}),1):0},flushAll:()=>(s.clear(),a.clear(),"OK"),dbsize:()=>{let e=0;for(var t of s.keys())d(t)&&s.has(t)&&e++;return e},...o,...e,...n,...f};return{...h,createRedisQueue:(e,t,r)=>((n,e,t={})=>{let{concurrency:r=1,pollInterval:a=500,maxRetries:s=3,baseRetryDelay:i=1e3,dlqKeySuffix:o="_DLQ"}=t,l=0,c=!1,d,u=""+n+o,E=async()=>{var a=h.lpop(n);if(null==a)l--;else{let r;try{r=JSON.parse(a)}catch{return h.rpush(u,JSON.stringify({malformedTaskString:a,error:"Failed to parse task JSON",failedAt:(new Date).toISOString()})),l--,void(c||f())}var{originalTask:a,retryCount:o=0}=r;try{await e(a)}catch(e){let t=o+1;t<=s?(await new Promise(e=>setTimeout(e,i*Math.pow(2,t-1))),h.rpush(n,JSON.stringify({originalTask:a,retryCount:t}))):h.rpush(u,JSON.stringify({taskPayloadAtFailure:r,error:e instanceof Error?e.message:String(e),errorStack:e instanceof Error?e.stack:void 0,failedAt:(new Date).toISOString()}))}finally{l--,c||f()}}},f=()=>{if(!c)for(;l<r&&(l++,E(),0!==h.lrange(n,0,0).length||0!==l););},p=()=>{c||(f(),d=setTimeout(p,a))};return p(),{enqueue:e=>{e=h.rpush(n,JSON.stringify({originalTask:e,retryCount:0}));return!c&&l<r&&(clearTimeout(d),p()),e},stop:()=>{c=!0,clearTimeout(d)},get length(){return h.lrange(n,0,-1).length},get isRunning(){return!c},getDLQName:()=>u,get dlqLength(){return h.lrange(u,0,-1).length},viewDLQ:(e=0,t=-1)=>h.lrange(u,e,t).map(e=>JSON.parse(e))}})(e,t,r)}},xdRedis=createRedisInstance,signData=(e,t)=>crypto.createHmac("sha256",String(t)).update(e).digest("base64url"),generateSessionId=()=>crypto.randomBytes(32).toString("base64url"),isSecureConnection=(e,t)=>Boolean(e.socket?.encrypted)||t&&"https"===String(e.headers["x-forwarded-proto"]||"").toLowerCase().split(",")[0]?.trim(),getClientIp=(e,t)=>t&&e.headers["x-forwarded-for"]?String(e.headers["x-forwarded-for"]).split(",")[0].trim():e.socket?.remoteAddress||"",getHostname=e=>String(e.headers.host||"").trim().replace(/:.*/,""),generateEtag=e=>`"${e.size.toString(16)}-${Math.floor(e.mtimeMs).toString(16)}"`,appendVaryHeader=(e,t)=>{if(!e)return t;let r=new Set(e.split(",").map(e=>e.trim()).filter(Boolean));return t.split(",").map(e=>e.trim()).forEach(e=>r.add(e)),Array.from(r).join(", ")},sanitizeRedirectUrl=e=>"string"!=typeof e||e.includes("\n")||e.includes("\r")?"/":e,createCookieHandler=()=>{let o=(e,t,r={})=>{if(!e||"string"!=typeof e)throw new TypeError("Cookie name must be a non-empty string");if(!/^[\w!#$%&'*+\-.0-9^`|~]+$/.test(e))throw new TypeError("Invalid cookie name");let a=encodeURIComponent(e)+"="+encodeURIComponent(t);var{maxAge:e,expires:t,domain:r,path:o="/",secure:n,httpOnly:s=!0,sameSite:i}=r;if(Number.isFinite(e)&&0<=e&&(a+="; Max-Age="+Math.floor(e)),t instanceof Date&&(a+="; Expires="+t.toUTCString()),r){if(!/^\.[a-z0-9.-]+$/i.test(r))throw new TypeError("Invalid domain");a+="; Domain="+r}if(o){if(!/^\/[\w!#$%&'()*+\-./:<>?@[\]\\^_`{|}~]*$/.test(o))throw new TypeError("Invalid path");a+="; Path="+o}if(s&&(a+="; HttpOnly"),n&&(a+="; Secure"),"Strict"===i||"Lax"===i||"None"===i)a+="; SameSite="+i;else if(void 0!==i)throw new TypeError("Invalid SameSite value");return a},a=(e,t,r,a)=>{var t=o(t,r,a);r=t,t=(a=e).getHeader("Set-Cookie"),Array.isArray(t)?a.setHeader("Set-Cookie",[...t,r]):a.setHeader("Set-Cookie",[r])};return{parse:e=>{if(!e)return Object.create(null);var t,r=Object.create(null);for(t of e.split(";")){var a=t.trim(),o=a.indexOf("=");if(0<o){var n=a.slice(0,o).trim(),a=a.slice(o+1).trim();if(n)try{r[n]=decodeURIComponent(a)}catch{r[n]=a}}}return r},serialize:o,set:a,setAll:(e,t,r)=>{if(!t||"object"!=typeof t)throw new TypeError("Cookie map is required");var t=Object.entries(t).map(([e,t])=>o(e,t,r)),a=e.getHeader("Set-Cookie");Array.isArray(a)?e.setHeader("Set-Cookie",[...a,...t]):e.setHeader("Set-Cookie",t)},clear:(e,t,r={})=>{a(e,t,"",{...r,maxAge:0,expires:new Date(0)})},get:(e,t)=>e[t],has:(e,t)=>t in e}},xdCookie=createCookieHandler(),createRateLimiter=(n=9e5,s=100)=>{let i=xdLRU({max:1e4,ttl:n,updateAgeOnGet:!1});return(e,t,r)=>{var e=e.ip||e.connection?.remoteAddress||"",a=Date.now();let o=i.get(e);o||(o={count:0,reset:a+n},i.set(e,o,{ttl:n})),o.count++;e=Math.max(0,s-o.count);if(t.setHeader("X-RateLimit-Limit",String(s)),t.setHeader("X-RateLimit-Remaining",String(e)),t.setHeader("X-RateLimit-Reset",String(Math.floor(o.reset/1e3))),o.count>s)return t.setHeader("Retry-After",String(Math.ceil((o.reset-a)/1e3))),t.status(429).json({error:"Too many requests",retryAfter:Math.ceil((o.reset-a)/1e3)});r()}},rateLimiterMiddleware=createRateLimiter(),corsMiddleware=(e,t,r)=>{var a=e.headers.origin||"*";t.setHeader("Vary",appendVaryHeader(String(t.getHeader("Vary")||""),"Origin, Access-Control-Request-Method, Access-Control-Request-Headers")),t.setHeader("Access-Control-Allow-Origin",a),t.setHeader("Access-Control-Allow-Methods","GET, POST, PUT, DELETE, HEAD, OPTIONS"),t.setHeader("Access-Control-Allow-Headers","Content-Type, Authorization, X-API-Key"),t.setHeader("Access-Control-Max-Age","86400"),t.setHeader("Access-Control-Allow-Credentials","true"),"OPTIONS"===e.method?(t.statusCode=204,t.end()):r()},errorHandlerMiddleware=(e,t,r,a)=>{var o;if(!r.headersSent)return"LIMIT_FILE_SIZE"===e?.code?r.status(400).json({error:"File too large"}):"entity.parse.failed"===e?.type?r.status(400).json({error:"Invalid JSON"}):(o={error:"Internal server error"},"development"===process.env.NODE_ENV&&(o.message=String(e?.message||e),o.stack=e?.stack),void r.status(500).json(o));try{r.end()}catch{}},serveFileAsync=async(e,r,t,a="GET",o,n,s,i)=>{let l="/"===t?"/index.html":t;try{l=decodeURIComponent(l)}catch{}l=path.posix.normalize(l).replace(/^(\.\.[/\\])+/,"");let c=path.resolve(o,"."+l);if(!c.startsWith(o+path.sep)&&c!==o)return!1;try{var d=await fs.stat(c);if(!d.isFile())return!1;var u=path.extname(c).slice(1).toLowerCase(),E=generateEtag(d),f=(r.setHeader("etag",E),r.setHeader("last-modified",d.mtime.toUTCString()),r.setHeader("accept-ranges","bytes"),r.setHeader("cache-control",0<s?"public, max-age="+s:"public, max-age=0, must-revalidate"),r.setHeader("content-type",n[u]||"application/octet-stream"),i&&!/^(text\/html|application\/json)/i.test(r.getHeader("content-type")||"")&&r.setHeader("x-content-type-options","nosniff"),String(e.headers["if-none-match"]||"")),p=e.headers["if-modified-since"]?new Date(e.headers["if-modified-since"]):null;if(f&&f===E||p&&!isNaN(p.getTime())&&d.mtime<=p)r.statusCode=304,r.end();else if("HEAD"===a)r.setHeader("content-length",String(d.size)),r.statusCode=200,r.end();else{var h=String(e.headers.range||"");if(h.startsWith("bytes=")){var g,m=h.slice(6).split(",")[0].split("-");let e=m[0]?parseInt(m[0],10):0,t=m[1]?parseInt(m[1],10):d.size-1;Number.isNaN(e)&&(e=0),Number.isNaN(t)&&(t=d.size-1),e>t||e<0||t>=d.size?(r.statusCode=416,r.setHeader("content-range","bytes */"+d.size),r.end()):(r.statusCode=206,r.setHeader("content-range",`bytes ${e}-${t}/`+d.size),r.setHeader("content-length",String(t-e+1)),(g=fsSync.createReadStream(c,{start:e,end:t})).on("error",e=>{log(LOG_LEVELS.ERROR,`Error reading file range ${c}: `+e.message),r.headersSent||(r.statusCode=500,r.end("Internal Server Error"))}),g.pipe(r))}else{r.setHeader("content-length",String(d.size));var O=fsSync.createReadStream(c);O.on("error",e=>{log(LOG_LEVELS.ERROR,`Error reading file ${c}: `+e.message),r.headersSent||(r.statusCode=500,r.end("Internal Server Error"))}),O.pipe(r)}}return!0}catch(e){return errorHandler.handleError(e,{operation:"serveFileAsync",filePath:c,method:a,relativePath:t}),!1}},parseMultipartData=async(e,t,r={})=>{var{maxFileSize:o=10485760,maxFiles:n=10,maxFields:s=100}=r,i={fields:{},files:[]},l=Buffer.from("--"+t),c=Buffer.from("\r\n\r\n");let d=e.indexOf(l);if(-1!==d)for(d+=l.length;d<e.length&&!e.slice(d,d+2).equals(Buffer.from("--"));){e.slice(d,d+2).equals(Buffer.from("\r\n"))&&(d+=2);var u=e.indexOf(c,d);if(-1===u)break;var E=e.slice(d,u).toString("utf8");let a={};E.split("\r\n").forEach(e=>{var t,r=e.indexOf(":");0<r&&(t=e.slice(0,r).trim().toLowerCase(),e=e.slice(r+1).trim(),a[t]=e)});var E=u+4,u=e.indexOf(l,E),E=e.slice(E,-1===u?e.length:u-2),f=a["content-disposition"]||"",p=f.match(/\bname="([^"]+)"/),f=f.match(/\bfilename="([^"]+)"/),p=p?p[1]:"",f=f?f[1]:null;if(f){if(i.files.length>=n)throw createErrorWithCode("Too many files","LIMIT_FILE_COUNT");if(E.length>o)throw createErrorWithCode("File too large","LIMIT_FILE_SIZE");i.files.push({name:p,filename:f,contentType:a["content-type"]||"application/octet-stream",data:E})}else if(p){if(Object.keys(i.fields).length>=s)throw createErrorWithCode("Too many fields","LIMIT_FIELD_COUNT");i.fields[p]=E.toString("utf8")}d=-1===u?e.length:u}return i},parseRequestBody=(r,l,c={})=>new Promise((a,o)=>{let n=String(r.headers["content-type"]||"").toLowerCase();var e=parseInt(r.headers["content-length"]||"0",10);if(Number.isFinite(e)&&l<e)return r.destroy(new Error("Payload Too Large")),a(null);let t=0,s=[],i=!1;r.on("data",e=>{i||((t+=e.length)>l?(i=!0,r.destroy(new Error("Payload Too Large")),o(createErrorWithCode("Payload Too Large","LIMIT_FILE_SIZE"))):s.push(e))}),r.on("end",async()=>{if(!i)try{var e,t,r=Buffer.concat(s);if(n.includes("json"))try{a(JSON.parse(r.toString("utf8")))}catch(e){o(createErrorWithCode("Invalid JSON payload","INVALID_JSON"))}else n.includes("x-www-form-urlencoded")?a(parseUrlSearchParams(r.toString("utf8"))):n.includes("multipart/form-data")?(e=n.match(/boundary=(?:"([^"]+)"|([^;\s]+))/i))?(t=e[1]||e[2],a(await parseMultipartData(r,t,c))):o(createErrorWithCode("Invalid boundary in multipart/form-data","INVALID_BOUNDARY")):a(r.toString("utf8"))}catch(e){"LIMIT_FILE_SIZE"===e.code||"LIMIT_FILE_COUNT"===e.code?a(null):o(e)}}),r.on("error",e=>{o(e)}),r.on("close",()=>{i||0!==t||a(null)})}),createSessionManager=(e,r)=>{let n=new Map;return{withSessionLock:async(e,t)=>{var r=n.get(e)||Promise.resolve();let a,o=new Promise(e=>{a=e});n.set(e,r.then(()=>o)),await r;try{return await t()}finally{a(),n.get(e)===r.then(()=>o)&&n.delete(e)}},getSessionData:async e=>{if(!e)return null;try{var t=r.get("sess:"+e);return t?JSON.parse(t):null}catch{return null}},setSessionData:async(e,t)=>{r.set("sess:"+e,safeJsonStringify(t),{ttl:3600})},destroySessionData:async e=>{r.del("sess:"+e)},getSessionId:async(e,t)=>{e=e.cookies.sid;if(e?.includes(".")){var[e,r]=e.split(".",2);if(r===signData(e,t))return e}return generateSessionId()}}},createWebSocket=(o,e,t={})=>{let n=new EventEmitter,{maxPayload:l=16777216,pingInterval:r=3e4,pingTimeout:a=1e4,maxClients:s=1e3}=t,i=WS_READY_STATES.OPEN,c=[],d=null,u=null,E=null,f=null,p="",h=0;t=s||1e3;let g={get readyState(){return i},get CONNECTING(){return WS_READY_STATES.CONNECTING},get OPEN(){return WS_READY_STATES.OPEN},get CLOSING(){return WS_READY_STATES.CLOSING},get CLOSED(){return WS_READY_STATES.CLOSED},socket:o,request:e,on:(e,t)=>(n.on(e,t),g),once:(e,t)=>(n.once(e,t),g),off:(e,t)=>(n.off(e,t),g),removeListener:(e,t)=>(n.removeListener(e,t),g),send:(e,t={})=>{if(i!==WS_READY_STATES.OPEN)return!1;t=t.binary||Buffer.isBuffer(e)?WS_OPCODES.BINARY:WS_OPCODES.TEXT,e=Buffer.isBuffer(e)?e:Buffer.from(String(e),"utf8");if(e.length>l)return log(LOG_LEVELS.WARN,`WebSocket payload too large: ${e.length} > `+l),w(1009,"Payload too large"),!1;t=m(t,e,!0);try{return o.write(t),!0}catch{return!1}},close:(e=1e3,t="")=>{if(i!==WS_READY_STATES.CLOSED&&i!==WS_READY_STATES.CLOSING){i=WS_READY_STATES.CLOSING,f=e,p=t;var r=Buffer.alloc(2+Buffer.byteLength(t)),t=(t&&r.write(t,2,"utf8"),r.writeUInt16BE(e,0),m(WS_OPCODES.CLOSE,r,!0));try{o.write(t)}catch{}setTimeout(()=>{i!==WS_READY_STATES.CLOSED&&L()},5e3)}},ping:(e=Buffer.alloc(0))=>{if(i!==WS_READY_STATES.OPEN)return!1;e=Buffer.isBuffer(e)?e:Buffer.from(String(e),"utf8"),e=m(WS_OPCODES.PING,e,!0);try{return o.write(e),!0}catch{return!1}},pong:(e=Buffer.alloc(0))=>{if(i!==WS_READY_STATES.OPEN)return!1;e=Buffer.isBuffer(e)?e:Buffer.from(String(e),"utf8"),e=m(WS_OPCODES.PONG,e,!0);try{return o.write(e),!0}catch{return!1}},terminate:()=>L()},m=(e,t,r=!0)=>{var a=t.length;let o=2,n=0;65535<a?(o+=8,n=8):125<a&&(o+=2,n=2);var s=Buffer.alloc(o+a);if(s[0]=(r?128:0)|e,0===n)s[1]=a;else if(2===n)s[1]=126,s.writeUInt16BE(a,2);else{if(s[1]=127,a>=Number.MAX_SAFE_INTEGER)return w(1009,"Payload too large"),Buffer.alloc(0);s.writeBigUInt64BE(BigInt(a),2)}return t.copy(s,o),s},O=Buffer.alloc(0),R=()=>{for(;2<=O.length;){var a=O[0],o=O[1],n=0!=(128&a),s=15&a,i=0!=(128&o);let e=127&o;if(0!=(64&a)||0!=(32&a)||0!=(16&a))return void w(1002,"RSV bits must be 0");if(!i)return void w(1002,"Client frames must be masked");let t=2;if(126===e?t+=2:127===e&&(t+=8),t+=4,O.length<t)return;let r=2;if(126===e)e=O.readUInt16BE(r),r+=2;else if(127===e){o=O.readUInt32BE(r),a=O.readUInt32BE(r+4);if(0<o||a>Number.MAX_SAFE_INTEGER||a>l)return void w(1009,"Payload too large");e=Number(a),r+=8}if(e>l)return void w(1009,"Payload too large");i=t+e;if(O.length<i)return;o=O.slice(r,r+4),a=(r+=4,O.slice(r,r+e)),a=((t,r)=>{var a=Buffer.alloc(t.length);for(let e=0;e<t.length;e++)a[e]=t[e]^r[e%4];return a})(a,o);O=O.slice(i),o=n,i=a,n=void 0,8<=(a=s)?S(a,i):a===WS_OPCODES.CONTINUATION?null===d?w(1002,"Unexpected continuation frame"):(c.push(i),o&&(n=Buffer.concat(c),d!==WS_OPCODES.TEXT||isValidUTF8(n)?(y(d,n),c=[],d=null):w(1007,"Invalid UTF-8 in fragmented text message"))):null!==d?w(1002,"Expected continuation frame"):o?a!==WS_OPCODES.TEXT||isValidUTF8(i)?y(a,i):w(1007,"Invalid UTF-8 in text message"):(d=a,c=[i])}},S=(e,r)=>{if(e===WS_OPCODES.CLOSE){let e=1005,t="";if(2<=r.length&&(e=r.readUInt16BE(0),t=r.slice(2).toString("utf8")),i===WS_READY_STATES.OPEN){i=WS_READY_STATES.CLOSING;var a=Buffer.alloc(2),a=(a.writeUInt16BE(e,0),m(WS_OPCODES.CLOSE,a,!0));try{o.write(a)}catch{}}f=e,p=t,L()}else if(e===WS_OPCODES.PING){if(i===WS_READY_STATES.OPEN){a=m(WS_OPCODES.PONG,r,!0);try{o.write(a)}catch{}}n.emit("ping",r)}else e===WS_OPCODES.PONG&&(clearTimeout(E),E=null,n.emit("pong",r))},y=(e,t)=>{if(e===WS_OPCODES.TEXT)try{var r=t.toString("utf8");Buffer.from(r,"utf8"),n.emit("message",r,!1)}catch(e){log(LOG_LEVELS.ERROR,"Invalid UTF-8 in WebSocket message: "+e.message),w(1007,"Invalid UTF-8")}else e===WS_OPCODES.BINARY&&n.emit("message",t,!0)},w=(e,t)=>{i!==WS_READY_STATES.CLOSED&&g.close(e,t)},L=()=>{if(i!==WS_READY_STATES.CLOSED){i=WS_READY_STATES.CLOSED,clearInterval(u),clearTimeout(E),c=[],d=null;try{o.end()}catch{}try{o.destroy()}catch{}n.emit("close",f||1006,p||""),o.removeAllListeners(),n.removeAllListeners(),h--}};return++h>t?(log(LOG_LEVELS.WARN,`Rejecting WebSocket connection: ${h} > `+t),w(1013,"Too many connections")):(o.on("data",e=>{O=Buffer.concat([O,e]),R()}),o.on("close",L),o.on("error",e=>{n.emit("error",e),L()}),o.on("end",L),r<=0||(u=setInterval(()=>{i===WS_READY_STATES.OPEN&&(g.ping(),E=setTimeout(()=>{i===WS_READY_STATES.OPEN&&w(1006,"Pong timeout")},a))},r))),g},handleWebSocketUpgrade=(e,t,r,a,o)=>{var n,s=new URL(e.url,"http://"+(e.headers.host||"localhost")),i=s.pathname;let l=null,c={};for(n of a){if(n.pattern===i){l=n,c={};break}if(n.regex){var d=i.match(n.regex);if(d){l=n,c=d.groups||{};break}}}if(l){var a=e.headers["sec-websocket-key"],u=e.headers["sec-websocket-version"];if(a&&"13"===u){u=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade","Sec-WebSocket-Accept: "+crypto.createHash("sha1").update(a+WS_GUID).digest("base64")],a=e.headers["sec-websocket-protocol"];if(a&&o.protocols){let t=a.split(",").map(e=>e.trim());a=(Array.isArray(o.protocols)?o.protocols:[o.protocols]).find(e=>t.includes(e));a&&u.push("Sec-WebSocket-Protocol: "+a)}t.write(u.join("\r\n")+"\r\n\r\n");a=createWebSocket(t,e,o);a.path=i,a.query=parseUrlSearchParams(s.search),a.params=c,a.cookies=xdCookie.parse(e.headers.cookie||""),r&&0<r.length&&t.unshift(r),l.handler(a,e)}else t.write("HTTP/1.1 400 Bad Request\r\n\r\n"),t.destroy()}else t.write("HTTP/1.1 404 Not Found\r\n\r\n"),t.destroy()},xdWebSocket={createWebSocket:createWebSocket,handleUpgrade:handleWebSocketUpgrade},createServerApp=(r={})=>{let o={GET:[],POST:[],PUT:[],DELETE:[],HEAD:[]},n=[],c=[],d=path.resolve(r.static||"./public"),u=r.maxBody||1048576,E=!1!==r.spa,f=!1!==r.logs,p=String(r.sessionSecret||"default-secret"),h=!0===r.trustProxy,g=Number.isFinite(r.staticMaxAge)?Math.max(0,r.staticMaxAge):0,m=!1!==r.secureHeaders;var e=r.sessionStore||xdRedis({max:1e3});let O={...DEFAULT_MIME_TYPES},s={maxPayload:r.wsMaxPayload||16777216,pingInterval:r.wsPingInterval||3e4,pingTimeout:r.wsPingTimeout||1e4,protocols:r.wsProtocols||null,maxClients:r.maxWsClients||1e3},i=new Set,R=createSessionManager(p,e),t=setInterval(()=>{let e=0;for(var t of i)t.readyState!==WS_READY_STATES.CLOSED&&t.readyState!==WS_READY_STATES.CLOSING||(i.delete(t),e++);0<e&&log(LOG_LEVELS.DEBUG,`Cleaned up ${e} dead WebSocket connections`)},3e4),a=(process.once("SIGTERM",()=>{clearInterval(t);for(var e of i)try{e.close(1012,"Server restarting")}catch{}i.clear()}),process.once("SIGINT",()=>{clearInterval(t);for(var e of i)try{e.close(1012,"Server shutting down")}catch{}i.clear()}),(e,t,r)=>{var a=createRegexPattern(t);o[e].push({pattern:t,regex:a,handler:r})}),S=(e,t)=>{for(var r of o[e]){if(r.pattern===t)return{handler:r.handler,params:{}};if(r.regex){var a=t.match(r.regex);if(a)return{handler:r.handler,params:a.groups||{}}}}return null},y=async(r,a,o,n=0)=>{if(!(n>=o.length||a.writableEnded)){let t=!1;var e=e=>{if(!t){if(t=!0,e)throw e;return y(r,a,o,n+1)}};try{var s=o[n](r,a,e);s?.then&&(await s,t||a.writableEnded||await e())}catch(e){return errorHandlerMiddleware(e,r,a,()=>{})}}return!0};e=async(r,a)=>{let e=Date.now();var o,n;n=a,s=new URL((o=r).url,"http://"+(o.headers.host||"localhost")),o.path=s.pathname,o.query=parseUrlSearchParams(s.search),o.cookies=xdCookie.parse(o.headers.cookie||""),o.hostname=getHostname(o),o.secure=isSecureConnection(o,h),o.ip=getClientIp(o,h),n.status=e=>(n.statusCode=e,n),n.set=(e,t)=>(n.setHeader(e,t),n),n.vary=e=>(n.setHeader("Vary",appendVaryHeader(String(n.getHeader("Vary")||""),e)),n),n.type=e=>n.set("content-type",e),n.json=e=>{n.type(O.json),n.end(safeJsonStringify(e))},n.html=e=>{n.type(O.html),n.end(e)},n.send=e=>"object"!=typeof e||Buffer.isBuffer(e)?n.end(String(e)):n.json(e),n.redirect=(e,t)=>{n.status(e).set("location",sanitizeRedirectUrl(t)).end()},n.safeHtml=e=>n.html(safeText(e)),n.safeJson=e=>n.json(e),n.setHeader("x-response-time","0"),m&&(n.setHeader("x-frame-options","SAMEORIGIN"),n.setHeader("referrer-policy","no-referrer"),n.setHeader("cross-origin-opener-policy","same-origin"),n.setHeader("cross-origin-resource-policy","same-origin")),(async()=>{try{let e=await R.getSessionId(o,p);var t=await R.getSessionData(e);o.session=t||{},o.currentSessionId=e,o.saveSession=()=>R.withSessionLock(e,async()=>{await R.setSessionData(e,o.session),xdCookie.set(n,"sid",e+"."+signData(e,p),{httpOnly:!0,secure:o.secure,maxAge:3600,path:"/",sameSite:"Lax"})}),o.destroySession=()=>R.withSessionLock(e,async()=>{await R.destroySessionData(e),xdCookie.clear(n,"sid",{path:"/"})})}catch(e){console.error("Session initialization error:",e),o.session={},o.currentSessionId=null}})(),a.on("finish",()=>{f&&console.log(r.method+` ${r.path} `+`${a.statusCode||200} ${Date.now()-e}ms`)});try{var t=c.filter(e=>"*"===e.path||r.path.startsWith(e.path)).map(e=>e.middleware);if(await y(r,a,t),a.headersSent||a.writableEnded)return}catch(e){return errorHandlerMiddleware(e,r,a,()=>{})}if("HEAD"===r.method){let t=S("GET",r.path);if(t){r.params=t.params;var s=a.write;let e=a.end;a.write=()=>!0,a.end=function(){try{return e.call(a)}catch{}};try{await t.handler(r,a)}catch(e){errorHandlerMiddleware(e,r,a,()=>{})}return a.write=s,void(a.end=e)}return await serveFileAsync(r,a,r.path,"HEAD",d,O,g,m)?void 0:E&&await serveFileAsync(r,a,"/index.html","HEAD",d,O,g,m)?void 0:void a.status(404).end()}let i=S(r.method,r.path);if(i){r.params=i.params;try{if("GET"!==r.method&&"DELETE"!==r.method){var l=await parseRequestBody(r,u,{});if(null===l)return a.status(413).send("Payload Too Large");r.body=l}await i.handler(r,a)}catch(e){errorHandlerMiddleware(e,r,a,()=>{})}}else await serveFileAsync(r,a,r.path,"GET",d,O,g,m)||E&&await serveFileAsync(r,a,"/index.html","GET",d,O,g,m)||a.status(404).send("Not Found")};let l=r.https?https.createServer(r.tls||{},e):http.createServer(e),w=(l.on("upgrade",(e,t,r)=>{if("websocket"!==String(e.headers.upgrade||"").toLowerCase())t.write("HTTP/1.1 400 Bad Request\r\n\r\n"),t.destroy();else try{xdWebSocket.handleUpgrade(e,t,r,n,s)}catch(e){console.error("WebSocket upgrade error:",e),t.write("HTTP/1.1 500 Internal Server Error\r\n\r\n"),t.destroy()}}),{get:(e,t)=>(a("GET",e,t),w),post:(e,t)=>(a("POST",e,t),w),put:(e,t)=>(a("PUT",e,t),w),delete:(e,t)=>(a("DELETE",e,t),w),use:(e,t)=>(t=t,"function"==typeof(e=e)&&(t=e,e="*"),c.push({path:e,middleware:t}),w),ws:(e,t)=>{var r,a;return e=e,r=e=>{i.size>=s.maxClients?(log(LOG_LEVELS.WARN,`Rejecting WebSocket connection: max clients (${s.maxClients}) reached`),e.close(1013,"Too many connections")):(i.add(e),e.on("close",()=>{i.delete(e);try{e.socket.removeAllListeners(),e.removeAllListeners()}catch{}}),t(e))},a=createRegexPattern(e),n.push({pattern:e,regex:a,handler:r}),w},getWsClients:()=>Array.from(i).filter(e=>e.readyState===WS_READY_STATES.OPEN),broadcast:(e,t={})=>{var r,a=t.filter||(()=>!0),o=t.exclude?new Set(Array.isArray(t.exclude)?t.exclude:[t.exclude]):new Set;let n=0,s=0;for(r of i)if(r.readyState===WS_READY_STATES.OPEN&&!o.has(r)&&a(r))try{r.send(e,t),n++}catch(e){s++,errorHandler.handleError(e,{operation:"websocket.broadcast",clientInfo:{path:r.path}})}return 0<s&&log(LOG_LEVELS.WARN,`WebSocket broadcast: ${n} sent, ${s} failed`),{sent:n,failed:s}},listen:(e,t)=>(l.listen(e,()=>{console.log(`Server: http${r.https?"s":""}://localhost:`+e),t&&t()}),w),server:l,cleanup:()=>{clearInterval(t),i.clear()}});return!1!==r.rateLimit&&w.use(rateLimiterMiddleware),!1!==r.cors&&w.use(corsMiddleware),w},xdSrv={createApp:createServerApp},createLRUCache=(e={})=>{let{max:s=500,ttl:i=0,totalMaxSize:l=104857600,lru:a=!1,updateAgeOnGet:o=!1,dispose:n=null,maxEntrySize:t=10485760}=e,c=new Map,d=Date.now,u=0,E=e=>{if("string"==typeof e)return Buffer.byteLength(e,"utf8");if(Buffer.isBuffer(e))return e.length;try{var t=JSON.stringify(e);return Buffer.byteLength(t,"utf8")}catch{return 0}},f=(e,t,r)=>{t&&(u-=t.size,n?.(e,t.value,r)),c.delete(e)},p=(e,t)=>e&&(e.expiration>t||e.expiration===1/0),h=(e,t)=>{c.delete(e),c.set(e,t)},g=e=>t===1/0||E(e)<=t;return{get(e){var t=c.get(e),r=d();if(p(t,r))return(o&&null!=t.itemTtl&&t.itemTtl!==1/0?(r={...t,expiration:r+t.itemTtl},(a||o)&&h(e,r),r):(a&&h(e,t),t)).value;f(e,t,"stale")},set(e,t,{ttl:r}={}){var a,r=r??i,o=r===1/0?1/0:d()+r,n=E(t);return!g(t)||l<1/0&&n>l||((a=c.get(e))?(u-=a.size,a={...a,value:t,expiration:o,itemTtl:r,size:n},h(e,a)):((e=>{if(!(s<=0||c.size<s&&u+e<=l))for(var t=c.keys();0<c.size&&(c.size>=s||u+e>l);){var r=t.next().value,a=c.get(r);f(r,a,"evict")}})(n),c.set(e,{value:t,expiration:o,itemTtl:r,size:n})),u+=n),this},has(e){return p(c.get(e),d())},delete(e){f(e,c.get(e),"delete")},clear(){for(var[e,t]of c)f(e,t,"delete");c.clear(),u=0},peek(e){e=c.get(e);return p(e,d())?e.value:void 0},prune(){var e,t,r=d();let a=0;for([e,t]of c)p(t,r)||(f(e,t,"stale"),a++);return a},keys(){return Array.from(c.keys())},get size(){return c.size},get totalSize(){return u},canCacheEntry(e){return g(e)}}},createErrorFactory=(o,n)=>({init(e,t=n,r,a){e=new Error(e);return e.name=o,e.code=t,e.config=r,a&&null==e.cause&&(e.cause=a),e}}),XdError=createErrorFactory("XdError","EUNKNOWN"),HttpError=createErrorFactory("HttpError","EHTTP"),TimeoutError=createErrorFactory("TimeoutError","ETIMEOUT"),DecompressError=createErrorFactory("DecompressError","EDECOMPRESS"),requestInterceptors=[],responseInterceptors=[],addInterceptor=(e,t)=>{e.push(t)},addRequestInterceptor=e=>addInterceptor(requestInterceptors,e),addResponseInterceptor=e=>addInterceptor(responseInterceptors,e),isPlainObject=e=>e&&"object"==typeof e&&!Buffer.isBuffer(e)&&!(e instanceof URLSearchParams)&&!Array.isArray(e),clamp=e=>Math.max(0,Number.isFinite(e)?e:0),normalizeHeaderKey=e=>String(e).toLowerCase().replace(/[^a-z0-9\-]/g,"").replace(/^-+|-+$/g,"").replace(/-+/g,"-"),normalizeHeaders=e=>{if(!e||"object"!=typeof e)return Object.create(null);var t,r,a=Object.create(null);for(t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r=normalizeHeaderKey(t))&&null!=e[t]&&(a[r]=String(e[t]).replace(/[\r\n\t\f\v\0]/g," ").replace(/\s+/g," ").trim());return a},parseContentType=e=>{var t=(e||"").toLowerCase().trim().split(";"),r=t[0].trim();let a="utf8";for(let e=1;e<t.length;e++){var o=t[e].trim();if(o.startsWith("charset=")){a=o.substring(8).trim().toLowerCase();break}}return{type:r,charset:a,raw:e||""}},encodeFormData=e=>{var t,r=new URLSearchParams;for(t in e)Object.prototype.hasOwnProperty.call(e,t)&&null!=e[t]&&r.append(t,String(e[t]));return r.sort(),r.toString()},flattenObject=(e,t="")=>{var r,a=[];for(r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var o=e[r],n=t?t+"."+r:r;if(isPlainObject(o))a.push(...flattenObject(o,n));else if(Array.isArray(o))for(let e=0;e<o.length;e++){var s=o[e],i=`${n}[${e}]`;isPlainObject(s)?a.push(...flattenObject(s,i)):a.push([i,s])}else a.push([n,o])}return a},isFileObject=e=>e&&"object"==typeof e&&e.filename&&e.data&&Buffer.isBuffer(e.data),buildMultipartPart=(e,t,r)=>{var a,o,n;return isFileObject(t)?({filename:n,contentType:a="application/octet-stream",data:o}=t,[Buffer.from(`--${r}\nContent-Disposition: form-data; name="${e}"; filename="${n}"\nContent-Type: ${a}\n\n`,"utf8"),o,Buffer.from("\n","utf8")]):(n=String(t),Buffer.from(`--${r}\nContent-Disposition: form-data; name="${e}"\n${n}\n`,"utf8"))},prepareMultipartPayload=(e,t)=>{var r=flattenObject(e),a=[];for(let e=0;e<r.length;e++){var[o,n]=r[e];null!=n&&(o=buildMultipartPart(o,n,t),Array.isArray(o)?a.push(...o):a.push(o))}return a.push(Buffer.from(`--${t}--\r\n`,"utf8")),Buffer.concat(a)},validateBufferForDecompression=(e,t)=>{if(!Buffer.isBuffer(e)||e.length<2)return!1;switch(t){case"gzip":return 31===e[0]&&139===e[1];case"deflate":return 120===e[0]&&(156===e[1]||1===e[1]||218===e[1]);case"br":return 2<e.length&&(0!==e[0]||0!==e[1]);default:return!1}},decodeBuffer=(e,r,a={})=>{if(!Buffer.isBuffer(e)||0===e.length)return e;if(!validateBufferForDecompression(e,r)){if(r)throw DecompressError.init(`Invalid header for ${r} compression or corrupted buffer`,"EDECOMPRESS_INVALID_HEADER",a);return e}try{switch(r){case"br":return brotliDecompressSync(e);case"gzip":return gunzipSync(e);case"deflate":return inflateSync(e);default:return e}}catch(e){var o=e.code||"UNKNOWN";let t="Decompression failed for encoding: "+r;switch(o){case"Z_DATA_ERROR":t="Corrupted or invalid compressed data";break;case"Z_BUF_ERROR":t="Insufficient buffer space or incomplete data";break;case"Z_MEM_ERROR":t="Out of memory during decompression";break;case"Z_VERSION_ERROR":t="Incompatible zlib version for "+r;break;case"Z_STREAM_ERROR":t="Invalid compression stream parameters";break;case"Z_ERRNO":t="File I/O error during decompression";break;case"BUFFER_SHORTAGE":t="Buffer too short for decompression";break;case"ENOBUFS":t="No buffer space available during decompression";break;case"EINVAL":t="Invalid argument in decompression stream";break;default:t="Unknown decompression error: "+o}throw DecompressError.init(t,"EDECOMPRESS_"+o,a,e)}},shouldParseJson=e=>{e=e.type;return"application/json"===e||e.endsWith("+json")},combineSignals=(e,t)=>{if(!e)return t||null;if(!t)return e;if(e.aborted)return e;if(t.aborted)return t;let r=new AbortController,a=()=>{r.signal.aborted||r.abort()};return e.addEventListener("abort",a,{once:!0}),t.addEventListener("abort",a,{once:!0}),r.signal.addEventListener("abort",()=>{e.removeEventListener("abort",a),t.removeEventListener("abort",a)},{once:!0}),r.signal},createKeepAliveAgents=()=>({http:new http.Agent({keepAlive:!0,keepAliveMsecs:1e3}),https:new https.Agent({keepAlive:!0,keepAliveMsecs:1e3})}),keepAliveAgents=createKeepAliveAgents(),processInterceptors=async(e,t,r,a)=>{let o={...e};for(let e=0;e<r.length;e++)try{var n=await r[e](o);n&&(o={...o,...n})}catch(e){throw XdError.init(a,"EINTERCEPTOR",t,e)}return o},processRequestInterceptors=(e,t=requestInterceptors)=>processInterceptors(e,e,t,"Request interceptor failed"),processResponseInterceptors=(e,t,r=responseInterceptors)=>processInterceptors(e,t,r,"Response interceptor failed"),buildRequestOptions=e=>{var{method:t="GET",url:r,headers:a={},keepAlive:o=!0,agent:n,signal:s,decompress:i=!0}=e,l=new URL(r),r="https:"===l.protocol;if("GET"===t.toUpperCase()&&isPlainObject(e.data))for(var c in e.data)Object.prototype.hasOwnProperty.call(e.data,c)&&null!=e.data[c]&&l.searchParams.append(c,String(e.data[c]));a=normalizeHeaders(a);return a.accept||(a.accept="application/json, */*;q=0.8"),!1===i||a["accept-encoding"]||(a["accept-encoding"]="gzip, deflate, br"),{hostname:l.hostname,port:l.port||(r?443:80),path:""+l.pathname+l.search,method:t.toUpperCase(),headers:a,signal:s,agent:n||(o?keepAliveAgents[r?"https":"http"]:void 0)}},preparePayload=(e,t)=>{if(null==e)return null;let r=null,a=t["content-type"];var o;return Buffer.isBuffer(e)?r=e:"string"==typeof e?r=Buffer.from(e,"utf8"):isPlainObject(e)?a&&a.includes("application/x-www-form-urlencoded")?r=Buffer.from(encodeFormData(e),"utf8"):a=a&&a.includes("multipart/form-data")?(o="----xdReq"+Date.now()+Math.random().toString(36).substr(2,9),r=prepareMultipartPayload(e,o),a||"multipart/form-data; boundary="+o):(o=JSON.stringify(e),r=Buffer.from(o,"utf8"),a||"application/json; charset=utf-8"):r=Buffer.from(String(e),"utf8"),r&&!t["content-length"]&&(t["content-length"]=r.length.toString()),a&&!t["content-type"]&&(t["content-type"]=a),r},createResponse=(e,t,r,a={})=>({status:e.statusCode||0,statusText:e.statusMessage||"",headers:e.headers,config:t,request:e.req,url:t.url,method:t.method,data:r,duration:Date.now()-(t._startTime||Date.now()),meta:{...a}}),handleStreamResponse=(e,t,r,a)=>{r&&clearTimeout(r),a(createResponse(e,t,e))},handleBufferResponse=async(t,e,r,a,o,n)=>{var t=1===t.length?t[0]:Buffer.concat(t),s=(e.headers["content-encoding"]||"").toLowerCase().trim();let i=t,l=null;if(!1!==r.decompress)try{i=decodeBuffer(t,s,r)}catch(e){l=e,i=t}var c=parseContentType(e.headers["content-type"]),d=r.responseType||"auto";let u,E=null;if("buffer"===d)u=i;else{var f=i.toString(c.charset);if("json"===d||"auto"===d&&shouldParseJson(c))try{u=JSON.parse(f)}catch(e){E=e,u=f}else u=f}d=createResponse(e,r,u,{parseError:E?String(E.message):null,decompressError:l?String(l.message):null,encoding:s,contentType:c.raw,raw:r.keepRaw?t:void 0,size:t.length});a&&clearTimeout(a),o(d)},coreRequest=async e=>{let i=await processRequestInterceptors(e),{method:t="GET",url:r,data:a,timeout:o=1e4,stream:l=!1,decompress:n=!0}=i;if("string"!=typeof r||!r.trim())throw XdError.init("URL is required","EURL",i);let s;try{s=new URL(r)}catch(e){throw XdError.init("Invalid URL: "+r,"EURL",i,e)}if("http:"!==s.protocol&&"https:"!==s.protocol)throw XdError.init("Unsupported protocol: "+s.protocol,"EPROTOCOL",i);let c="https:"===s.protocol?https:http,d=new AbortController,u=combineSignals(d.signal,i.signal),E=clamp(o);i._startTime=Date.now();e=t.toUpperCase(),"GET"!==e&&"HEAD"!==e||(a=null),e={...i.headers};let f=preparePayload(a,e),p=buildRequestOptions({...i,url:s.toString(),headers:e,signal:u,decompress:n});return new Promise((e,a)=>{let o=null,t=null,r=!1,n=(e,t)=>{r||(r=!0,o&&(clearTimeout(o),o=null),e(t))},s=()=>{t&&!t.destroyed&&t.destroy(),r||n(a,XdError.init("Request aborted","EABORT",i))};u.addEventListener("abort",s,{once:!0});try{0<E&&(o=setTimeout(()=>{t&&!t.destroyed&&t.destroy(),d.abort(new Error(`Timeout after ${E}ms`))},E)),(t=c.request(p,r=>{if(u.removeEventListener("abort",s),l)handleStreamResponse(r,i,o,e);else{let t=[];r.on("data",e=>{u.aborted?r.destroy():t.push(e)}),r.on("end",()=>{u.aborted||handleBufferResponse(t,r,i,o,e,a).catch(a)}),r.on("error",e=>{u.aborted||n(a,XdError.init("Response error: "+e.message,e.code||"ERESPONSE",i,e))}),r.statusCode&&400<=r.statusCode&&r.resume()}})).on("error",e=>{"ABORT_ERR"===e.code||u.aborted||n(a,XdError.init("Request error: "+e.message,e.code||"EREQUEST",i,e))}),f&&t.write(f),t.end()}catch(e){n(a,XdError.init(e.message||"Request initialization failed","EREQUEST_INIT",i,e))}})},createRetryPlugin=(e={})=>{let{retries:s=3,delay:i=100,maxDelay:l=1e4,idempotentMethods:r=new Set(["GET","HEAD","OPTIONS","TRACE"]),transientErrors:c=new Set(["ECONNRESET","ENOTFOUND","ECONNREFUSED","EAI_AGAIN","ETIMEDOUT","ESOCKETTIMEDOUT"])}=e;return n=>async e=>{var t=(e.method||"GET").toUpperCase();if(!r.has(t))return n(e);let a;for(let r=0;r<=s;r++)try{return await n(e)}catch(e){if(a=e,r===s)throw e;var o="HttpError"===e.name&&e.meta?.status;if(!("TimeoutError"===e.name||c.has(e.code))&&!(500<=o||408===o||429===o||503===o))throw e;let t=Math.min(i*Math.pow(2,r),l)+100*Math.random();await new Promise(e=>setTimeout(e,t))}throw a}},createCachePlugin=(e={})=>{let{max:t=100,ttl:s=3e5,totalMaxSize:i=1/0,maxEntrySize:l=1/0,updateAgeOnGet:r=!1,excludeHeaders:c=["authorization","cookie"],lru:a=!0}=e,d=createLRUCache({max:t,ttl:s,totalMaxSize:i,lru:a,updateAgeOnGet:r,maxEntrySize:l,dispose:(e,t)=>{t?.data&&(Buffer.isBuffer(t.data)||"object"==typeof t.data)&&(t.data=null)}});return n=>async e=>{if("GET"!==(e.method||"GET").toUpperCase()||e.stream||!1===e.cache)return n(e);let t=normalizeHeaders(e.headers);if(c.some(e=>t[e.toLowerCase()])||t["cache-control"]?.includes("no-store"))return n(e);var r=new URL(e.url),a=(e.headers.vary||"").split(",").map(e=>e.trim().toLowerCase()).includes("accept")&&t.accept||"",o=[...r.searchParams.entries()].sort(([e],[t])=>e.localeCompare(t)).map(([e,t])=>e+"="+t).join("&"),r=""+r.origin+r.pathname+(o?"?"+o:"")+"|"+a,o=d.get(r);if(void 0!==o)return{...o,fromCache:!0};a=await n(e);if(200<=a.status&&a.status<300&&0!==i&&0!==l){if(!d.canCacheEntry(a))return a;o=(a.headers["cache-control"]||"").toLowerCase().match(/max-age=(\d+)/),e=o?1e3*parseInt(o[1],10):s;d.set(r,{...a},{ttl:e})}return a}},globalDefaults={},globalRequestPipeline=coreRequest,applyPlugin=(e,t,r)=>{if("function"==typeof t)return t(r)(e);switch(t){case"retry":return createRetryPlugin(r)(e);case"cache":return createCachePlugin(r)(e);default:throw new Error("Unknown plugin: "+t)}},usePlugin=(e,t)=>(globalRequestPipeline=applyPlugin(globalRequestPipeline,e,t),xdReq),mergeOptions=(t,e,r)=>{t={...t,...e};if(r&&(t.url=r),t.baseURL&&t.url&&!t.url.match(/^https?:\/\//))try{t.url=new URL(t.url,t.baseURL).href}catch(e){throw XdError.init("Invalid baseURL or relative URL","EURL",t,e)}return t},createClient=(e={},t=coreRequest,o=[...requestInterceptors],n=[...responseInterceptors])=>{let s=t,r={...e},a=[...o],i=[...n];let l=async e=>{e=e;var t,r,e=await processRequestInterceptors(e,o),a=await s(e);if(t=a,r=e,a=await processResponseInterceptors(t,r,n),!0!==e.stream&&400<=a.status)throw t=a.data?String(a.data).slice(0,512):"",r=`HTTP ${a.status} ${a.statusText} for `+e.url+(t?" :: "+t:""),HttpError.init(r,"HTTP_"+a.status,e,{headers:a.headers,duration:a.duration,size:a.meta?.size||0});return a},c=(e,t={})=>l(mergeOptions(r,t,e));c.defaults=(e={})=>(Object.assign(r,e),c);var d=["get","post","put","patch","delete","head","options"];for(let e=0;e<d.length;e++){let a=d[e];c[a]=(e,t,r={})=>{e={method:a.toUpperCase(),url:e,...r};return void 0!==t&&(e.data=t),c(e.url,e)}}return c.addRequestInterceptor=e=>{a.push(e),o.push(e)},c.addResponseInterceptor=e=>{i.push(e),n.push(e)},c.use=(e,t)=>(l=applyPlugin(l,e,t),c),c.create=(e={})=>createClient({...r,...e},s,[...a],[...i]),c},xdReq=createClient();xdReq.use=usePlugin,xdReq.defaults=(e={})=>(Object.assign(globalDefaults,e),xdReq),xdReq.addRequestInterceptor=addRequestInterceptor,xdReq.addResponseInterceptor=addResponseInterceptor,xdReq.create=(e={})=>createClient({...globalDefaults,...e},globalRequestPipeline);export{xdTok,xdDrawNum,xdHash,xdUnHash,xdbLite,xdRedis,xdLRU,xdCookie,escapeAny,safeText,safeAttr,safeUrlAttr,errorHandlerMiddleware as errorHandler,corsMiddleware as cors,createRateLimiter,rateLimiterMiddleware,xdWebSocket,xdSrv,xdReq};

/* *** DOCUMENTATION v2.0 ***
 * 📘 XD LIBS - PRODUCTION-READY REFERENCE
 * =================================================================================================
 *
 * BASICS:
 * - All exported functions: { xdTok, xdDrawNum, xdHash, xdUnHash, xdbLite, xdSrv, xdReq, xdRedis, xdLRU, xdCookie, xdWebSocket }
 * - Import: import { xdbLite, xdSrv, xdReq } from './xdLibs.js';
 * - Zero dependencies: Pure Node.js core modules only
 * - ESM only: Works with Node.js 18+
 *
 * CRITICAL IMPORTANT NOTES:
 * 1. ALL functions are ASYNC where applicable (except utilities)
 * 2. ALWAYS wrap route handlers in try-catch (xdSrv returns 500 on unhandled errors)
 * 3. WebSocket .send() requires STRING data - use JSON.stringify() for objects
 * 4. xdHash is OBFUSCATION, not encryption - do not use for sensitive data
 * 5. File operations are ATOMIC with process-safe locks
 * =================================================================================================
 *
 * [1] 🗄️ xdbLite - JSON Database with Atomic Operations
 * -------------------------------------------------------------------------------------------------
 * Purpose: File-based JSON database with ACID-like guarantees
 * File format: Always array of objects, e.g. [{ id: '...', data: ... }, ...]
 *
 * CONFIGURATION (Required before first use):
 * await xdbLite.config({
 * basePath: './data', // Required: Where JSON files are stored
 * cachingEnabled: false, // Default: false - DON'T enable without cache invalidation plan
 * cacheTTL: 60000, // Default: 60000ms (1 minute)
 * logLevel: 'INFO' // DEBUG|INFO|WARN|ERROR|NONE
 * });
 *
 * IMPORTANT: Cache invalidation MUST be handled manually:
 * - After .edit.id(): Automatically invalidates cache for that record
 * - After .del.id(): Automatically invalidates cache for that record
 * - After .edit.all()/.del.all(): Automatically invalidates all cache for file
 * - For external file modifications: call xdbLite.cache.invalidate(filePath)
 *
 * CRUD OPERATIONS (All return Promise):
 * .add.id(filePath, record) → { path: string, record: object }
 * - If record.id missing → generates xdTok(16)
 * - If id exists → throws XDB_ERROR_CODES.RECORD_EXISTS
 * - Example: await xdbLite.add.id('users.json', { name: 'John', age: 30 })
 *
 * .add.all(filePath, data, { overwrite: true }) → { path: string }
 * - data: array of objects OR single object
 * - If file exists and overwrite=false → throws XDB_ERROR_CODES.OPERATION_FAILED
 * - Example: await xdbLite.add.all('posts.json', postsArray, { overwrite: false })
 *
 * .view.id(filePath, id) → { path: string, record: object, fromCache: boolean? }
 * - Throws XDB_ERROR_CODES.RECORD_NOT_FOUND if missing
 * - Example: const { record } = await xdbLite.view.id('posts.json', 'post123')
 *
 * .view.all(filePath) → { path: string, data: array }
 * - Returns empty array if file doesn't exist (no error)
 * - Example: const { data } = await xdbLite.view.all('posts.json')
 *
 * .view.more(filePath, options) → { path: string, data: array, meta: object }
 * - options MUST include at least one of: filter, sort, skip, limit
 * - filter: (item) => boolean
 * - sort: { key: 'field', order: 'asc'|'desc' } OR array of those
 * - Example: await xdbLite.view.more('posts.json', { filter: p => p.published, sort: { key: 'date', order: 'desc' }, limit: 10 })
 *
 * .edit.id(filePath, id, updates) → { path: string, record: object }
 * - Merges updates into existing record (shallow merge)
 * - Throws XDB_ERROR_CODES.RECORD_NOT_FOUND if id doesn't exist
 * - Updates cache for that id
 * - Example: await xdbLite.edit.id('users.json', 'user123', { status: 'active' })
 *
 * .edit.all(filePath, newData) → { path: string }
 * - Completely replaces file content with newData (array or object)
 * - Invalidates entire file cache
 * - Example: await xdbLite.edit.all('config.json', { version: '2.0' })
 *
 * .del.id(filePath, id) → { path: string, deletedId: string }
 * - Throws XDB_ERROR_CODES.RECORD_NOT_FOUND if id doesn't exist
 * - Invalidates cache for that id
 * - Example: await xdbLite.del.id('posts.json', 'post456')
 *
 * .del.all(filePath) → { path: string }
 * - Writes empty array [] to file
 * - Invalidates all file cache
 * - Example: await xdbLite.del.all('temporary.json')
 *
 * .del.file(filePath) → { path: string }
 * - Deletes file from disk
 * - Invalidates all file cache
 * - No error if file doesn't exist
 * - Example: await xdbLite.del.file('obsolete_data.json')
 *
 * DIRECTORY OPERATIONS:
 * .dir.add(path) → { path: string } // Creates directory recursively
 * .dir.del(path) → { path: string } // Deletes directory recursively
 * .dir.rename(oldPath, newPath) → { oldPath, newPath } // Atomic rename
 * .dir.list(path) → string[] // Returns array of filenames
 *
 * FILE MOVING:
 * .move.file(sourcePath, targetPath) → { source, target }
 * - Atomic rename (filesystem-level)
 * - Invalidates cache for both paths
 *
 * CACHE MANAGEMENT:
 * .cache.clear() → void // Clears entire cache
 * .cache.invalidate(filePath, id?) → void // Invalidates specific file/record cache
 *
 * ERROR CODES (throw objects with .code property):
 * XDB_ERROR_CODES.FILE_NOT_FOUND // File doesn't exist
 * XDB_ERROR_CODES.DIR_NOT_FOUND // Directory doesn't exist
 * XDB_ERROR_CODES.IO_ERROR // Filesystem error
 * XDB_ERROR_CODES.INVALID_JSON // File isn't valid JSON
 * XDB_ERROR_CODES.RECORD_NOT_FOUND // ID doesn't exist
 * XDB_ERROR_CODES.RECORD_EXISTS // ID already exists (collision)
 * XDB_ERROR_CODES.OPERATION_FAILED // Other operational error
 *
 * BEST PRACTICES:
 * 1. ALWAYS use try-catch with specific error.code checks
 * 2. Enable caching ONLY if you handle cache invalidation properly
 * 3. Use .move.file() instead of manual rename for atomic operations
 * 4. .dir.list() returns only names, not stats - use fs for advanced ops
 * =================================================================================================
 *
 * [2] 🌐 xdSrv - Minimalist Web Server with WebSockets
 * -------------------------------------------------------------------------------------------------
 * IMPORTANT: NOT a replacement for Express/Fastify - designed for simplicity
 *
 * INITIALIZATION:
 * const app = xdSrv.createApp({
 * static: './public', // Static files directory (optional)
 * cors: true, // Enable CORS headers (default: true)
 * logs: true, // Request logging (default: true)
 * secureHeaders: true, // Security headers (default: true)
 * sessionSecret: 'change-me', // REQUIRED for sessions
 * trustProxy: false, // Trust X-Forwarded-* headers
 * maxBody: 1048576, // Max request body size (default: 1MB)
 * staticMaxAge: 3600, // Cache-Control max-age for static files (seconds)
 * wsMaxPayload: 16777216, // WebSocket max message (default: 16MB)
 * wsPingInterval: 30000, // WebSocket ping interval (milliseconds)
 * wsPingTimeout: 10000, // WebSocket pong timeout
 * wsProtocols: ['chat', 'game'], // Supported subprotocols
 * maxWsClients: 1000, // Max concurrent WebSocket connections
 * rateLimit: true // Enable rate limiting (default: true)
 * });
 *
 * HTTP ROUTES:
 * app.get(pattern, handler) // GET requests
 * app.post(pattern, handler) // POST requests
 * app.put(pattern, handler) // PUT requests
 * app.delete(pattern, handler) // DELETE requests
 *
 * Pattern syntax:
 * - '/api/users' // Exact match
 * - '/api/users/:id' // Named parameter → req.params.id
 * - '/api/users/:id/posts/:postId' // Multiple params
 *
 * MIDDLEWARE:
 * app.use(pattern, (req, res, next) => { ...; next(); })
 * app.use((req, res, next) => { ...; next(); }) // Global middleware
 *
 * REQUEST OBJECT (req):
 * req.method // 'GET', 'POST', etc.
 * req.path // '/api/users/123'
 * req.query // { param: 'value' } from ?param=value
 * req.params // { id: '123' } from /users/:id
 * req.body // Parsed JSON, FormData or Buffer
 * req.cookies // { session: 'abc' } parsed cookies
 * req.ip // Client IP (respects trustProxy)
 * req.hostname // Host header without port
 * req.secure // Boolean (true if HTTPS)
 * req.session // Session object (initially {})
 * req.currentSessionId // Current session ID (string)
 *
 * SESSION METHODS (async):
 * await req.saveSession() // Persists req.session to store
 * await req.destroySession() // Clears session from store + cookie
 *
 * RESPONSE OBJECT (res):
 * res.status(code) → res // Sets HTTP status: res.status(404)
 * res.set(key, value) → res // Sets header: res.set('X-API', '1')
 * res.type(mime) → res // Sets Content-Type: res.type('json')
 * res.vary(header) → res // Adds to Vary header: res.vary('Accept')
 *
 * SENDING RESPONSES:
 * res.json(data) // Sends JSON with proper headers
 * res.html(string) // Sends HTML with text/html
 * res.send(string|object) // Auto-detects type, strings as text/html
 * res.redirect(code, url) // Redirects: res.redirect(302, '/')
 *
 * SECURITY HELPERS:
 * res.safeHtml(string) // Escapes HTML entities: & → &amp;
 * res.safeJson(data) // JSON.stringify with circular ref handling
 *
 * STATIC FILES:
 * - Serves files from 'static' directory
 * - Auto-indexes: / → /index.html
 * - Supports Range requests (partial content)
 * - Sends 304 Not Modified if ETag matches
 * - Respects staticMaxAge for Cache-Control
 *
 * WEBSOCKETS (app.ws):
 * app.ws(pattern, (ws, req) => {
 * // ws has same req properties: ws.path, ws.query, ws.params, ws.cookies
 * // WebSocket-specific:
 * ws.on('open', () => {}) // When connection opened
 * ws.on('message', (data, isBinary) => {
 * // data: If string sent → string, if Buffer/Binary → Buffer
 * // isBinary: boolean
 * // IMPORTANT: ws.send() expects STRING for text, Buffer/ArrayBuffer for binary
 * ws.send(JSON.stringify({ type: 'response' }));
 * });
 * ws.on('close', (code, reason) => {}) // code: number, reason: string
 * ws.on('error', (error) => {})
 * ws.on('ping', (data) => {}) // Received ping frame
 * ws.on('pong', (data) => {}) // Received pong frame
 *
 * // Control methods:
 * ws.send(data, { binary: boolean })
 * ws.ping(data) // data optional
 * ws.pong(data) // data optional
 * ws.close(code, reason) // code default: 1000
 * ws.terminate() // Force close without handshake
 *
 * // Properties:
 * ws.readyState // 0: CONNECTING, 1: OPEN, 2: CLOSING, 3: CLOSED
 * ws.socket // Raw net.Socket
 * ws.request // Original HTTP request
 * ws.path // WebSocket path
 * });
 *
 * BROADCASTING:
 * const result = app.broadcast(data, {
 * exclude: [wsClient1, wsClient2], // Clients to skip
 * filter: (client) => true/false // Predicate function
 * binary: false // Send as binary (default: false)
 * });
 * // Returns: { sent: number, failed: number }
 *
 * SERVER CONTROL:
 * app.listen(port, callback) // Starts server: app.listen(3000)
 * app.server // Raw http/https server instance
 * app.getWsClients() → WebSocket[] // Returns array of connected clients
 * app.cleanup() // Cleans up WebSocket intervals
 *
 * ERROR HANDLING:
 * - Unhandled errors in routes → 500 with error message
 * - JSON parse errors → 400 'Invalid JSON'
 * - Request body too large → 413 'Payload Too Large'
 * - 404 for unknown routes (falls back to static if enabled)
 *
 * WARNINGS:
 * 1. req.body exists only for POST/PUT with Content-Type
 * 2. WebSocket .send() requires string/Buffer - objects auto-converted to [object Object]
 * 3. Sessions MUST use req.saveSession() after modifications
 * 4. app.use() middleware runs BEFORE route matching
 * =================================================================================================
 *
 * [3] 📡 xdReq - Advanced HTTP Client with Plugins
 * -------------------------------------------------------------------------------------------------
 * Designed for: API calls, web scraping, proxy requests
 *
 * BASIC USAGE:
 * const response = await xdReq.get('https://api.example.com/data', {
 * headers: { 'Authorization': 'Bearer token' },
 * timeout: 5000, // Abort after ms (default: 10000)
 * responseType: 'json' // 'json'|'buffer'|'text'|'auto' (default: 'auto')
 * });
 *
 * REQUEST OPTIONS (all optional):
 * {
 * url: '...',
 * method: 'GET', // GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS
 * data: any, // Request body (auto-handled)
 * headers: { 'X-Custom': 'value' },
 * timeout: 10000, // milliseconds
 * responseType: 'auto', // auto-detects from Content-Type
 * decompress: true, // Auto-decompress gzip/brotli
 * stream: false, // If true, returns response stream
 * keepRaw: false, // Keep raw buffer in response.meta.raw
 * cache: true, // Use cache plugin if enabled
 * signal: AbortSignal, // AbortController signal
 * keepAlive: true, // HTTP keep-alive
 * baseURL: 'https://api.example.com' // For relative paths
 * }
 *
 * RESPONSE OBJECT:
 * {
 * data: parsed/json/string/buffer, // Parsed based on responseType
 * status: 200, // HTTP status code
 * statusText: 'OK', // HTTP status text
 * headers: {}, // Response headers (normalized lowercase)
 * config: {}, // Original request config
 * request: http.ClientRequest, // Raw request object
 * url: 'https://...', // Final URL
 * method: 'GET',
 * duration: 245, // Request duration in ms
 * meta: {
 * parseError: null/string, // JSON parse error if any
 * decompressError: null/string, // Decompression error if any
 * encoding: 'gzip'/'deflate'/null,
 * contentType: 'application/json',
 * raw: Buffer, // Only if keepRaw: true
 * size: 12345 // Response size in bytes
 * }
 * }
 *
 * INSTANCE CREATION (with defaults):
 * const api = xdReq.create({
 * baseURL: 'https://api.example.com',
 * headers: { 'Authorization': 'Bearer ...' },
 * timeout: 30000
 * });
 *
 * // All methods available:
 * api.get('endpoint')
 * api.post('endpoint', data)
 * api.put('endpoint', data)
 * api.patch('endpoint', data)
 * api.delete('endpoint')
 * api.head('endpoint')
 * api.options('endpoint')
 *
 * PLUGINS (built-in):
 * // Enable retry plugin (idempotent methods only: GET, HEAD, OPTIONS, TRACE)
 * api.use('retry', {
 * retries: 3, // Number of retry attempts
 * delay: 100, // Base delay between retries (ms)
 * maxDelay: 10000, // Maximum delay
 * transientErrors: [ // Error codes to retry on
 * 'ECONNRESET', 'ENOTFOUND',
 * 'ECONNREFUSED', 'EAI_AGAIN',
 * 'ETIMEDOUT', 'ESOCKETTIMEDOUT'
 * ]
 * });
 *
 * // Enable cache plugin (GET requests only)
 * api.use('cache', {
 * max: 100, // Maximum number of cached responses
 * ttl: 300000, // Cache TTL in ms (5 minutes)
 * totalMaxSize: Infinity, // Maximum cache size in bytes
 * maxEntrySize: Infinity, // Maximum per-entry size
 * excludeHeaders: ['authorization', 'cookie'] // Don't cache these headers
 * });
 *
 * INTERCEPTORS (modify requests/responses):
 * // Request interceptor (modify config before request)
 * api.addRequestInterceptor(config => {
 * config.headers['X-Timestamp'] = Date.now();
 * return config; // Must return modified config
 * });
 *
 * // Response interceptor (modify/validate response)
 * api.addResponseInterceptor(response => {
 * if (response.status === 401) {
 * throw new Error('Unauthorized');
 * }
 * response.data.timestamp = Date.now();
 * return response; // Must return response
 * });
 *
 * ADVANCED FEATURES:
 * // Multipart/form-data uploads
 * await api.post('upload', {
 * file: {
 * filename: 'image.jpg',
 * contentType: 'image/jpeg',
 * data: Buffer.from(...)
 * },
 * field: 'value'
 * });
 *
 * // Stream response (for large files)
 * const response = await api.get('large-file', { stream: true });
 * response.data.pipe(fs.createWriteStream('output.bin'));
 *
 * // AbortController for cancellation
 * const controller = new AbortController();
 * setTimeout(() => controller.abort(), 5000);
 * try {
 * await api.get('slow-endpoint', { signal: controller.signal });
 * } catch (err) {
 * if (err.name === 'AbortError') console.log('Request cancelled');
 * }
 *
 * ERROR TYPES:
 * HttpError - HTTP status >= 400 (err.meta contains full response)
 * TimeoutError - Request timeout
 * DecompressError - Decompression failed
 * XdError - General request/response errors
 *
 * BEST PRACTICES:
 * 1. ALWAYS use try-catch - errors are thrown for status >= 400
 * 2. Set reasonable timeouts per endpoint type
 * 3. Use responseType: 'buffer' for binary data
 * 4. Enable keepAlive for multiple requests to same host
 * 5. Cache only safe-to-cache endpoints
 * =================================================================================================
 *
 * [4] 🧠 xdRedis - In-Memory Redis-Compatible Store
 * -------------------------------------------------------------------------------------------------
 * IMPORTANT: In-memory only, lost on process restart. Use for caching/sessions.
 *
 * INITIALIZATION:
 * const db = xdRedis({
 * max: 1000, // Maximum keys in store (default: 1000)
 * // Note: No persistence options - memory only
 * });
 *
 * STRING OPERATIONS:
 * db.set(key, value, { ttl: seconds }) → 'OK' // ttl: seconds, -1 = no expiry
 * db.get(key) → string|null // Returns null if not found/expired
 * db.exists(key) → 0|1 // 1 = exists, 0 = doesn't
 * db.del(key) → 0|1 // 1 = deleted, 0 = didn't exist
 * db.expire(key, seconds) → 0|1 // Set TTL, 1 = set, 0 = key doesn't exist
 * db.ttl(key) → -2|-1|seconds // -2 = doesn't exist, -1 = no expiry
 * db.incr(key) → number // Increments integer value
 * db.decr(key) → number // Decrements integer value
 * db.append(key, string) → newLength // Appends to string value
 *
 * LIST OPERATIONS (Redis lists):
 * db.lpush(key, ...values) → newLength // Prepends values
 * db.rpush(key, ...values) → newLength // Appends values
 * db.lpop(key) → string|null // Removes and returns first element
 * db.rpop(key) → string|null // Removes and returns last element
 * db.lrange(key, start, end) → string[] // Returns slice (0-based, -1 = last)
 *
 * HASH OPERATIONS (key-value within key):
 * db.hset(key, field, value) → 0|1 // 1 = new field, 0 = updated
 * db.hget(key, field) → string|null // Returns field value
 * db.hdel(key, ...fields) → number // Number of fields deleted
 * db.hkeys(key) → string[] // All field names
 * db.hgetall(key) → object // { field: value, ... }
 *
 * SET OPERATIONS (unique collections):
 * db.sadd(key, ...members) → number // Number of new members added
 * db.srem(key, ...members) → number // Number of members removed
 * db.smembers(key) → string[] // All members
 * db.sismember(key, member) → 0|1 // 1 = is member, 0 = is not
 *
 * BULK OPERATIONS:
 * db.keys(pattern) → string[] // pattern supports * wildcard
 * db.dbsize() → number // Number of keys in store
 * db.flushAll() → 'OK' // Deletes all keys
 *
 * JOB QUEUE (Redis-like queue with DLQ):
 * const queue = db.createRedisQueue('jobs', async (task) => {
 * // Process task
 * if (task.type === 'email') await sendEmail(task.data);
 * }, {
 * concurrency: 1, // Concurrent workers (default: 1)
 * pollInterval: 500, // Queue polling interval ms (default: 500)
 * maxRetries: 3, // Max retries before DLQ (default: 3)
 * baseRetryDelay: 1000, // Base delay between retries ms (default: 1000)
 * dlqKeySuffix: '_DLQ' // Dead Letter Queue suffix (default: '_DLQ')
 * });
 *
 * // Enqueue task (any JSON-serializable data)
 * queue.enqueue({ type: 'email', data: { to: '...' } }) → queue length
 *
 * // Control
 * queue.stop() // Stops processing
 * queue.length // Current queue length (getter)
 * queue.isRunning // Is queue active? (getter)
 * queue.dlqLength // Dead letter queue length (getter)
 * queue.viewDLQ(start, end) → [] // View DLQ contents
 *
 * IMPORTANT NOTES:
 * 1. All values stored as strings (JSON.stringify for objects)
 * 2. TTL precision: ~1 second
 * 3. Pattern matching: * wildcard only (no regex)
 * 4. No persistence - memory only
 * 5. Thread-safe within single Node.js process
 * =================================================================================================
 *
 * [5] 🛠️ UTILITIES - Security, Random, Cookies
 * -------------------------------------------------------------------------------------------------
 * SECURITY:
 * xdTok(length=36) → string // Time-sortable unique ID (similar to ULID)
 * xdHash(data) → string|null // Obfuscation (XOR + Base64) - NOT encryption
 * xdUnHash(hash) → string|null // Reverse of xdHash
 *
 * HTML ESCAPING (XSS prevention):
 * safeText(string) → string // Escapes: & < > " '
 * safeAttr(name, value, options) → string // name="escaped-value"
 * options: { quoted: true } // true → name="value", false → name=value
 * safeUrlAttr(name, url) → string // Sanitizes URL protocols (blocks javascript:)
 *
 * RANDOM NUMBERS:
 * xdDrawNum(min, max) → object // Returns: { next(), set(min, max) }
 * // Usage:
 * const rng = xdDrawNum(1, 100);
 * rng.next() → random number 1-100
 * rng.set(50, 500).next() → random number 50-500
 *
 * COOKIE HANDLING (xdCookie):
 * xdCookie.parse(header) → object // Parse 'Cookie:' header
 * xdCookie.serialize(name, value, options) → string // Create 'Set-Cookie:' value
 * xdCookie.set(res, name, value, options) // Set cookie on response
 * xdCookie.setAll(res, cookies, options) // Set multiple cookies
 * xdCookie.clear(res, name, options) // Clear cookie (maxAge: 0)
 * xdCookie.get(cookies, name) → string|null // Get from parsed cookies
 * xdCookie.has(cookies, name) → boolean // Check existence
 *
 * Cookie options:
 * {
 * maxAge: 3600, // seconds
 * expires: Date, // Date object
 * domain: '.example.com',
 * path: '/',
 * secure: true, // HTTPS only
 * httpOnly: true, // No JavaScript access
 * sameSite: 'Lax' // 'Strict'|'Lax'|'None'
 * }
 *
 * UNIVERSAL ESCAPE:
 * escapeAny(value, options) → string // Context-aware escaping
 * // options: { context: 'htmlContent'|'htmlAttribute'|'jsString'|'cssString'|'url'|'auto' }
 * // Example: escapeAny(userInput, { context: 'htmlContent' })
 *
 * CHARACTER ESCAPING:
 * escapeAny('alert(1)', { context: 'jsString' }) → "alert\x281\x29"
 * escapeAny(userInput, { context: 'auto', inAttribute: true, targetName: 'onclick' }) → properly escaped
 *
 * BEST PRACTICES:
 * 1. ALWAYS escape user input with safeText() or safeAttr()
 * 2. Use xdCookie.set() with httpOnly: true, secure: true for sessions
 * 3. xdHash for obfuscation only (e.g., temporary tokens)
 * 4. xdTok for database IDs (not crypto-secure random)
 * 5. escapeAny() when unsure of context
 * =================================================================================================
 *
 * [6] 🎯 xdLRU - LRU Cache Implementation
 * -------------------------------------------------------------------------------------------------
 * const cache = xdLRU({
 * max: 500, // Maximum items in cache
 * ttl: 60000, // Time-to-live in ms (0 = no expiry)
 * maxMemoryBytes: 52428800, // 50MB memory limit
 * updateAgeOnGet: false, // Reset TTL on access
 * dispose: (key, value, reason) => { ... } // Called on eviction
 * });
 *
 * Methods:
 * cache.get(key) → value|undefined
 * cache.set(key, value, { ttl: ms }) → cache (chainable)
 * cache.has(key) → boolean
 * cache.delete(key) → boolean (true if deleted)
 * cache.clear() → void
 * cache.peek(key) → value|undefined (no TTL reset)
 * cache.prune() → number (removed expired items)
 * cache.keys() → iterator
 * cache.size → number
 * cache.memoryUsage → number (bytes)
 * cache.canCacheEntry(value) → boolean (fits memory limits?)
 *
 * AUTOMATIC CLEANUP:
 * - Auto-prunes expired entries every 5 minutes
 * - Auto-evicts when max items or max memory reached
 * - dispose() called for each evicted entry
 *
 * USE CASES:
 * - Session storage (TTL-based)
 * - API response caching
 * - Expensive computation memoization
 * - Rate limiting counters
 * =================================================================================================
 *
 * [7] ⚡ xdWebSocket - Raw WebSocket Handler
 * -------------------------------------------------------------------------------------------------
 * Used internally by xdSrv. Exported for custom implementations.
 *
 * const { createWebSocket, handleUpgrade } = xdWebSocket;
 *
 * // Manual WebSocket upgrade handling:
 * if (req.headers.upgrade === 'websocket') {
 * handleUpgrade(req, socket, head, routes, options);
 * }
 *
 * // Creating custom WebSocket:
 * const ws = createWebSocket(socket, req, {
 * maxPayload: 16777216, // Max message size
 * pingInterval: 30000, // Ping interval ms
 * pingTimeout: 10000, // Pong timeout ms
 * maxClients: 1000 // Max connections
 * });
 *
 * Low-level control only. Use xdSrv.createApp().ws() for production.
 * =================================================================================================
 *
 * [8] 🚨 ERROR HANDLING PATTERNS
 * -------------------------------------------------------------------------------------------------
 * try {
 * // xdbLite operations
 * const { record } = await xdbLite.view.id('data.json', '123');
 * } catch (err) {
 * if (err.code === 'XDB_RECORD_NOT_FOUND') {
 * res.status(404).json({ error: 'Not found' });
 * } else {
 * console.error('Database error:', err);
 * res.status(500).json({ error: 'Internal error' });
 * }
 * }
 *
 * try {
 * // xdReq operations
 * const response = await xdReq.get('https://api.com/data');
 * if (response.status >= 400) {
 * throw new Error(`API error: ${response.status}`);
 * }
 * } catch (err) {
 * if (err.name === 'HttpError') {
 * console.log('HTTP error:', err.meta);
 * } else if (err.name === 'TimeoutError') {
 * console.log('Request timeout');
 * }
 * }
 *
 * // WebSocket error handling
 * ws.on('error', (err) => {
 * console.error('WebSocket error:', err);
 * ws.close(1011, 'Internal error');
 * });
 *
 * // Global error handler for xdSrv
 * app.use((err, req, res, next) => {
 * console.error('Unhandled error:', err);
 * res.status(500).json({ error: 'Something went wrong' });
 * });
 *
 * COMMON ERROR CODES:
 * XDB_ERROR_CODES.* // Database errors
 * ECONNREFUSED, ETIMEDOUT // Network errors
 * ENOENT // File not found
 * LIMIT_FILE_SIZE // Body too large
 * INVALID_JSON // JSON parse error
 * =================================================================================================
 *
 * [9] 🧪 TESTING TIPS
 * -------------------------------------------------------------------------------------------------
 * // Mock xdbLite for testing
 * import { xdbLite } from './xdLibs.js';
 * import { test } from 'node:test';
 * import assert from 'node:assert';
 * import { temporaryDirectory } from 'tempy';
 *
 * test('xdbLite operations', async () => {
 * const testDir = temporaryDirectory();
 * await xdbLite.config({ basePath: testDir, cachingEnabled: false });
 *
 * const { record } = await xdbLite.add.id('test.json', { name: 'test' });
 * assert.ok(record.id);
 *
 * const { data } = await xdbLite.view.all('test.json');
 * assert.strictEqual(data.length, 1);
 *
 * await xdbLite.del.file('test.json');
 * });
 *
 * // Test xdSrv routes
 * const app = xdSrv.createApp({ logs: false });
 * app.get('/test', (req, res) => res.json({ ok: true }));
 *
 * // Use supertest or manual http requests
 *
 * // Clean up after tests
 * afterEach(async () => {
 * await xdbLite.cache.clear();
 * });
 *
 * PERFORMANCE NOTES:
 * - xdbLite: ~1000 ops/sec (depends on filesystem)
 * - xdRedis: ~50k ops/sec (in-memory)
 * - xdSrv: ~10k req/sec (simple routes)
 * - xdReq: ~100 req/sec (depends on network)
 * =================================================================================================
 *
 * [10] ⚖️ PRODUCTION DEPLOYMENT
 * -------------------------------------------------------------------------------------------------
 * 1. Set proper sessionSecret (32+ random chars)
 * 2. Enable trustProxy if behind reverse proxy
 * 3. Configure rate limiting thresholds
 * 4. Set appropriate wsMaxClients
 * 5. Use process manager (PM2, systemd)
 * 6. Enable logging for monitoring
 * 7. Set NODE_ENV=production
 * 8. Regular backup of xdbLite data directory
 * 9. Monitor memory usage (xdRedis can grow)
 * 10. Implement health checks
 *
 * SECURITY CHECKLIST:
 * [ ] All user input escaped with safeText()/safeAttr()
 * [ ] Session cookies: httpOnly: true, secure: true
 * [ ] CORS properly configured
 * [ ] Rate limiting enabled
 * [ ] File uploads validated (size, type)
 * [ ] No sensitive data in xdHash() (use crypto for encryption)
 * [ ] WebSocket origin validation if needed
 * [ ] Directory traversal prevented (xdSrv handles this)
 *
 * TROUBLESHOOTING:
 * Issue: xdbLite.cache.invalidate() not working
 * Fix: Check file path is relative to basePath, use absolute paths
 *
 * Issue: xdReq cache plugin caching POST requests
 * Fix: cache plugin only caches GET by default, verify method
 *
 * Issue: WebSocket messages showing [object Object]
 * Fix: Always JSON.stringify() objects before ws.send()
 *
 * Issue: xdRedis losing data on restart
 * Fix: Expected behavior - memory only. Implement persistence layer if needed
 *
 * Issue: xdSrv returning 404 for valid routes
 * Fix: Check route patterns match exactly, middleware not blocking
 *
 * Issue: xdReq timeout too short
 * Fix: Increase timeout option or implement retry plugin
 * =================================================================================================
 */


// // TESTS
// import { describe, it, beforeEach, afterEach } from 'node:test';import assert from 'node:assert';
// const testFileLockSystem = () => { const fileLocks = new Map(); const lockCleanup = new Set(); const LOCK_TIMEOUT = 30000; const LOCK_RETRY_INTERVAL = 50;  const acquireLock = async (filePath, timeout = LOCK_TIMEOUT) => {  const fullPath = path.resolve(filePath);  const startTime = Date.now();  const processId = process.pid + '_' + Math.random();   if (lockCleanup.has(`${fullPath}:${processId}`)) {  throw new Error(`Process ${processId} already holds lock for ${filePath} - potential deadlock`);  }  let retryCount = 0;  const maxRetries = Math.ceil(timeout / LOCK_RETRY_INTERVAL);  while (fileLocks.has(fullPath)) {  if (Date.now() - startTime > timeout) {   throw new Error(`Timeout waiting for lock on ${filePath} after ${timeout}ms`);  }   const lockData = fileLocks.get(fullPath);  if (lockData && lockData.expiresAt < Date.now()) {   fileLocks.delete(fullPath);   lockCleanup.delete(`${fullPath}:${lockData.processId}`);   break;  }   retryCount++;  if (retryCount > maxRetries) {   throw new Error(`Max retries exceeded for lock on ${filePath}`);  }   await new Promise(resolve => setTimeout(resolve, LOCK_RETRY_INTERVAL));  }  let release;  const lockPromise = new Promise(resolve => { release = resolve; });  const lockData = {  promise: lockPromise,  release: () => release(),  expiresAt: Date.now() + timeout,  processId: processId,  filePath: fullPath  };  fileLocks.set(fullPath, lockData);  lockCleanup.add(`${fullPath}:${processId}`);  return () => {  if (fileLocks.has(fullPath)) {   const currentLock = fileLocks.get(fullPath);   if (currentLock.processId === processId) {   fileLocks.delete(fullPath);   lockCleanup.delete(`${fullPath}:${processId}`);   }  }  }; };  return { acquireLock, fileLocks, lockCleanup }; };  const testUTF8Validation = () => { const isValidUTF8 = (buffer) => {  try {  const text = buffer.toString('utf8'); const reencoded = Buffer.from(text, 'utf8');   return buffer.equals(reencoded);  } catch {  return false;  } };  return { isValidUTF8 }; };  const createTestErrorHandler = () => { const errorListeners = new Set(); const unhandledRejections = new Map();  const handleError = (error, context = {}) => {  const errorWithContext = {  ...context,  message: error?.message || String(error),  stack: error?.stack,  code: error?.code,  timestamp: Date.now()  };  for (const listener of errorListeners) {  try {   listener('error', errorWithContext);  } catch {}  }  return errorWithContext; };  const handleAsyncError = async (operation, context = {}) => {  try {  return await operation();  } catch (error) {  return handleError(error, context);  } };  return { handleError, handleAsyncError, errorListeners }; };  const createTestCache = ({  max = 100,  ttl = 5000,  maxMemoryBytes = 1024 * 1024 } = {}) => { const cache = new Map(); let currentMemoryUsage = 0;  const calculateItemSize = (value) => {  if (typeof value === 'string') return Buffer.byteLength(value, 'utf8');  if (Buffer.isBuffer(value)) return value.length;  try {  return Buffer.byteLength(JSON.stringify(value), 'utf8');  } catch {  return 0;  } };  const set = (key, value) => {  const itemSize = calculateItemSize(value);   if (itemSize > maxMemoryBytes) {  return false;  }  while (cache.size >= max || currentMemoryUsage + itemSize > maxMemoryBytes) {  const firstKey = cache.keys().next().value;  if (!firstKey) break; const oldEntry = cache.get(firstKey);  currentMemoryUsage -= oldEntry.size;  cache.delete(firstKey);  }  cache.set(key, { value, size: itemSize, timestamp: Date.now() });  currentMemoryUsage += itemSize;  return true; };  const get = (key) => {  const entry = cache.get(key);  if (!entry) return undefined;   if (entry.timestamp + ttl < Date.now()) {  currentMemoryUsage -= entry.size;  cache.delete(key);  return undefined;  }   return entry.value; };  const getMemoryUsage = () => currentMemoryUsage;  return { set, get, getMemoryUsage, cache }; };  const testAsyncFileServing = () => { const serveFileAsync = async (filePath, response) => {  try {  const stats = await fs.stat(filePath);  if (!stats.isFile()) throw new Error('Not a file');  return true;  } catch (error) {  return false;  } };  return { serveFileAsync }; };  describe('File Lock System (Punkt 1)', () => { const testDir = './test-locks';  beforeEach(async () => {  await fs.mkdir(testDir, { recursive: true }); });  afterEach(async () => {  await fs.rm(testDir, { recursive: true, force: true }); });  it('powinien poprawnie nabywać i zwalniać blokadę', async () => {  const lockSystem = testFileLockSystem();  const testFile = path.join(testDir, 'test.json');  await fs.writeFile(testFile, '{}');  const release = await lockSystem.acquireLock(testFile);  assert(lockSystem.fileLocks.has(path.resolve(testFile)), 'Blokada powinna istnieć');   release();  assert(!lockSystem.fileLocks.has(path.resolve(testFile)), 'Blokada powinna być zwolniona'); });  it('powinien obsługiwać timeout przy oczekiwaniu na blokadę', async () => {  const lockSystem = testFileLockSystem();  const testFile = path.join(testDir, 'test.json');  await fs.writeFile(testFile, '{}');  const release1 = await lockSystem.acquireLock(testFile);   await assert.rejects(  async () => {   await lockSystem.acquireLock(testFile, 100);  },  /Timeout waiting for lock/,  'Powinien timeoutować'  );  release1(); });  it('powinien zapobiegać deadlock przez wykrywanie podwójnej blokady', async () => {  const lockSystem = testFileLockSystem();  const testFile = path.join(testDir, 'test.json');  await fs.writeFile(testFile, '{}');  const processId = process.pid + '_test';   lockSystem.lockCleanup.add(`${path.resolve(testFile)}:${processId}`);   await assert.rejects(  async () => {  const fullPath = path.resolve(testFile);   if (lockSystem.lockCleanup.has(`${fullPath}:${processId}`)) {   throw new Error(`Process ${processId} already holds lock for ${testFile} - potential deadlock`);   }  },  /already holds lock.*potential deadlock/,  'Powinien wykryć deadlock'  ); });  it('powinien czyścić wygasłe blokady', async () => {  const lockSystem = testFileLockSystem();  const testFile = path.join(testDir, 'test.json');  await fs.writeFile(testFile, '{}'); const expiredLock = {  promise: Promise.resolve(),  release: () => {},  expiresAt: Date.now() - 1000,  processId: 9999,  filePath: path.resolve(testFile)  };   lockSystem.fileLocks.set(path.resolve(testFile), expiredLock);  const release = await lockSystem.acquireLock(testFile);  assert(lockSystem.fileLocks.has(path.resolve(testFile)), 'Powinien nabyć nową blokadę');   release(); }); }); describe('WebSocket UTF-8 Validation (Punkt 2)', () => { const utf8 = testUTF8Validation();  it('powinien poprawnie walidować prawidłowe UTF-8', () => {  const validTexts = [  'Hello World',  'Zażółć gęślą jaźń',  '你好世界',  '🚀 Unicode emojis',  'Special chars: àáâãäåæçèéêë'  ];  validTexts.forEach(text => {  const buffer = Buffer.from(text, 'utf8');  assert(utf8.isValidUTF8(buffer), `Powinien zaakceptować: ${text}`);  }); });  it('powinien odrzucać nieprawidłowe UTF-8', () => {  const invalidBuffers = [  Buffer.from([0xFF, 0xFE]),   Buffer.from([0xC0, 0x80]),   Buffer.from([0xED, 0xA0, 0x80]),   Buffer.from([0xF5, 0x80, 0x80, 0x80])  ];  invalidBuffers.forEach(buffer => {  assert(!utf8.isValidUTF8(buffer), `Powinien odrzucić nieprawidłowy buffer`);  }); });  it('powinien obsługiwać puste bufory', () => {  assert(utf8.isValidUTF8(Buffer.alloc(0)), 'Pusty buffer powinien być prawidłowy'); });  it('powinien obsługiwać bufory ASCII', () => {  const asciiBuffer = Buffer.from('Hello World!', 'ascii');  assert(utf8.isValidUTF8(asciiBuffer), 'ASCII powinien być prawidłowym UTF-8'); }); });  describe('Central Error Handler (Punkt 3)', () => { let errorHandler;  beforeEach(() => {  errorHandler = createTestErrorHandler(); });  it('powinien poprawnie obsługiwać błędy synchroniczne', () => {  const testError = new Error('Test error');  const context = { operation: 'test', id: 123 };  const result = errorHandler.handleError(testError, context);  assert.strictEqual(result.message, 'Test error');  assert.strictEqual(result.operation, 'test');  assert.strictEqual(result.id, 123);  assert(result.timestamp instanceof Number || typeof result.timestamp === 'number'); });  it('powinien obsługiwać błędy asynchroniczne', async () => {  const asyncOperation = async () => {   throw new Error('Async test error');  };  const result = await errorHandler.handleAsyncError(asyncOperation, { context: 'async-test' });  assert.strictEqual(result.message, 'Async test error');  assert.strictEqual(result.context, 'async-test'); });  it('powinien obsługiwać nieobiektowe błędy', () => {  const result = errorHandler.handleError('String error', { type: 'string' });  assert.strictEqual(result.message, 'String error');  assert.strictEqual(result.type, 'string'); });  it('powinien wywoływać listenerów błędów', () => {  let capturedError = null;  errorHandler.errorListeners.add((type, error) => {   capturedError = error;  });  errorHandler.handleError(new Error('Listened error'));  assert(capturedError);  assert.strictEqual(capturedError.message, 'Listened error'); });  it('powinien obsługiwać błędy bez stacka', () => {  const error = { message: 'Custom error object' };  const result = errorHandler.handleError(error);  assert.strictEqual(result.message, 'Custom error object');  assert.strictEqual(result.stack, undefined); }); }); describe('Cache with Memory Limits (Punkt 5)', () => { let cache;  beforeEach(() => {  cache = createTestCache({ max: 3, ttl: 1000, maxMemoryBytes: 500 }); });  it('powinien ograniczać liczbę elementów', () => {  cache.set('key1', 'value1');  cache.set('key2', 'value2');  cache.set('key3', 'value3');  cache.set('key4', 'value4');   assert.strictEqual(cache.cache.size, 3, 'Powinien utrzymać maksymalnie 3 elementy');  assert.strictEqual(cache.get('key1'), undefined, 'Najstarszy element powinien być usunięty');  assert.strictEqual(cache.get('key4'), 'value4', 'Najnowszy element powinien istnieć'); });  it('powinien ograniczać użycie pamięci', () => {   const largeValue = 'x'.repeat(300);  cache.set('large1', largeValue);  cache.set('large2', largeValue);  const memoryBefore = cache.getMemoryUsage();  const success = cache.set('large3', largeValue); assert(memoryBefore > 0, 'Użycie pamięci powinno być większe niż 0');  assert(success || !success, 'Set powinien zwrócić boolean'); });  it('powinien obsługiwać TTL', async () => {  cache.set('temp', 'temporary');  assert.strictEqual(cache.get('temp'), 'temporary'); await new Promise(resolve => setTimeout(resolve, 1100));   assert.strictEqual(cache.get('temp'), undefined, 'Element powinien wygasnąć'); });  it('powinien poprawnie liczyć użycie pamięci', () => {  const value1 = 'Hello';  const value2 = Buffer.from('World');  const value3 = { test: 'object' };  cache.set('str', value1);  cache.set('buf', value2);  cache.set('obj', value3);  const usage = cache.getMemoryUsage();  assert(usage > 0, 'Użycie pamięci powinno być większe niż 0'); }); }); describe('Async File Serving (Punkt 6)', () => { const testDir = './test-files';  beforeEach(async () => {  await fs.mkdir(testDir, { recursive: true }); });  afterEach(async () => {  await fs.rm(testDir, { recursive: true, force: true }); });  it('powinien serwować pliki asynchronicznie', async () => {  const fileServer = testAsyncFileServing();  const testFile = path.join(testDir, 'test.txt');  const content = 'Test file content';  await fs.writeFile(testFile, content);  const mockResponse = {};  const result = await fileServer.serveFileAsync(testFile, mockResponse);  assert(result, 'Powinien pomyślnie obsłużyć istniejący plik'); });  it('powinien obsługiwać błędy podczas odczytu pliku', async () => {  const fileServer = testAsyncFileServing();  const nonExistentFile = path.join(testDir, 'nonexistent.txt');  const mockResponse = {};  const result = await fileServer.serveFileAsync(nonExistentFile, mockResponse);  assert(!result, 'Powinien zwrócić false dla nieistniejącego pliku'); });  it('powinien obsługiwać duże pliki poprzez streaming', async () => {  const fileServer = testAsyncFileServing();  const largeFile = path.join(testDir, 'large.txt');  const largeContent = 'x'.repeat(1024 * 1024);  await fs.writeFile(largeFile, largeContent);  const mockResponse = {};  const result = await fileServer.serveFileAsync(largeFile, mockResponse);  assert(result, 'Powinien pomyślnie obsłużyć duży plik'); }); }); describe('Integration Tests', () => { it('powinien obsługiwać pełny przepływ: lock -> operacja -> unlock', async () => {  const testDir = './test-integration';  const testFile = path.join(testDir, 'integration.json');   await fs.mkdir(testDir, { recursive: true });   const data = { counter: 0 };  await fs.writeFile(testFile, JSON.stringify(data));  for (let i = 0; i < 5; i++) {  const lockSystem = testFileLockSystem();  const release = await lockSystem.acquireLock(testFile); const fileData = JSON.parse(await fs.readFile(testFile, 'utf8'));  fileData.counter++;  await fs.writeFile(testFile, JSON.stringify(fileData)); release();  }   const finalData = JSON.parse(await fs.readFile(testFile, 'utf8'));  assert.strictEqual(finalData.counter, 5, 'Licznik powinien wynosić 5 po wszystkich operacjach');  await fs.rm(testDir, { recursive: true, force: true }); });  it('powinien obsługiwać kombinację cache + error handling', async () => {  const cache = createTestCache({ max: 2, ttl: 1000 });  const errorHandler = createTestErrorHandler(); cache.set('test', 'value');  assert.strictEqual(cache.get('test'), 'value', 'Cache powinien zwrócić wartość');  const error = new Error('Test error');  const result = errorHandler.handleError(error, { source: 'cache' });  assert.strictEqual(result.message, 'Test error');  assert.strictEqual(result.source, 'cache'); }); }); 

/*
▶ File Lock System (Punkt 1)
  ✔ powinien poprawnie nabywać i zwalniać blokadę (8.019797ms)
  ✔ powinien obsługiwać timeout przy oczekiwaniu na blokadę (110.76772ms)
  ✔ powinien zapobiegać deadlock przez wykrywanie podwójnej blokady (6.362604ms)
  ✔ powinien czyścić wygasłe blokady (9.52708ms)
✔ File Lock System (Punkt 1) (138.290021ms)
▶ WebSocket UTF-8 Validation (Punkt 2)
  ✔ powinien poprawnie walidować prawidłowe UTF-8 (0.87611ms)
  ✔ powinien odrzucać nieprawidłowe UTF-8 (0.483631ms)
  ✔ powinien obsługiwać puste bufory (0.326292ms)
  ✔ powinien obsługiwać bufory ASCII (0.425156ms)
✔ WebSocket UTF-8 Validation (Punkt 2) (3.33901ms)
▶ Central Error Handler (Punkt 3)
  ✔ powinien poprawnie obsługiwać błędy synchroniczne (1.797543ms)
  ✔ powinien obsługiwać błędy asynchroniczne (0.738717ms)
  ✔ powinien obsługiwać nieobiektowe błędy (0.323794ms)
  ✔ powinien wywoływać listenerów błędów (0.421198ms)
  ✔ powinien obsługiwać błędy bez stacka (0.330739ms)
✔ Central Error Handler (Punkt 3) (4.539652ms)
▶ Cache with Memory Limits (Punkt 5)
  ✔ powinien ograniczać liczbę elementów (1.316348ms)
  ✔ powinien ograniczać użycie pamięci (0.474791ms)
  ✔ powinien obsługiwać TTL (1102.874752ms)
  ✔ powinien poprawnie liczyć użycie pamięci (10.502529ms)
✔ Cache with Memory Limits (Punkt 5) (1116.468046ms)
▶ Async File Serving (Punkt 6)
  ✔ powinien serwować pliki asynchronicznie (6.820534ms)
  ✔ powinien obsługiwać błędy podczas odczytu pliku (1.858868ms)
  ✔ powinien obsługiwać duże pliki poprzez streaming (5.337251ms)
✔ Async File Serving (Punkt 6) (14.734433ms)
▶ Integration Tests
  ✔ powinien obsługiwać pełny przepływ: lock -> operacja -> unlock (8.1236ms)
  ✔ powinien obsługiwać kombinację cache + error handling (0.624744ms)
✔ Integration Tests (9.342158ms)
*/
